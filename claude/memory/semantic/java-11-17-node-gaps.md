---
id: sem-007
title: CPG Node Type System Gaps for Java 11-17 Features
type: semantic
tags: [java-11-17, node-system, records, sealed-classes, pattern-matching, switch-expressions, text-blocks, gap-analysis]
created: 2025-11-13
related: [sem-001, sem-002, ep-024]
---

# CPG Node Type System Gaps for Java 11-17 Features

## Overview

CPG's node type system has significant gaps in representing modern Java (11-17) language features. This document provides a structured inventory of missing node types and recommended extensions.

## Support Summary

```
Overall Support: 25% (1.25 of 5 major features)

Feature                        Support  Need
─────────────────────────────────────────────
Records (Java 14+)             30%      HIGH
Sealed Classes (Java 15+)       0%      HIGH
Pattern Matching (Java 14-17)   0%      CRITICAL
Switch Expressions (Java 12+)   5%      HIGH
Text Blocks (Java 15)           0%      MEDIUM
Local Variable Type (Java 10+)  95%     NONE
```

## Missing Node Types

### 1. Record Components
**Feature**: Records (Java 14+)  
**Problem**: No way to distinguish record parameters from regular fields

```kotlin
// Current: No node type for x, y
public record Point(int x, int y) {}

// Need:
class RecordComponentDeclaration : VariableDeclaration() {
    var recordDeclaration: RecordDeclaration? = null
    var componentIndex: Int = 0
    var isAutoGenerated: Boolean = false
}
```

### 2. Pattern Expressions
**Feature**: Pattern Matching (Java 14+)  
**Problem**: instanceof patterns cannot be represented

```kotlin
// Current: BinaryOperator (loses pattern binding)
if (obj instanceof String str) { ... }

// Need:
sealed class PatternExpression : Expression()

class TypePatternExpression : PatternExpression() {
    var type: Type? = null
    var bindingVariable: VariableDeclaration? = null
}

class RecordPatternExpression : PatternExpression() {
    var recordType: Type? = null
    var componentPatterns: List<PatternExpression> = emptyList()
}
```

### 3. Switch Expressions
**Feature**: Switch Expressions (Java 12+)  
**Problem**: Expression form confused with Statement form

```kotlin
// Current: SwitchStatement only
int val = switch(x) { case 1 -> 10; };

// Need:
class SwitchExpression : Expression() {
    var selector: Expression? = null
    var caseExpressions: List<CaseExpressionEntry> = emptyList()
}

data class CaseExpressionEntry(
    val labels: List<Expression>,
    val value: Expression,
    val isArrowForm: Boolean = false
)
```

### 4. Yield Statement
**Feature**: Switch Expressions (Java 13+)  
**Problem**: yield has no representation

```kotlin
// Current: Break for exit, but no explicit yield
switch(x) { case 1: { yield 10; } }

// Need:
class YieldStatement : Statement() {
    var expression: Expression? = null
}
```

### 5. Text Block Literal
**Feature**: Text Blocks (Java 15)  
**Problem**: Multiline strings have no special handling

```kotlin
// Current: Literal<String> for both
String s = "line1\nline2";
String tb = """
    line1
    line2
    """;

// Need:
class TextBlockLiteral : Literal<String>() {
    var indentationLevel: Int = 0
    var isTextBlock: Boolean = true
}
```

## Extensions to Existing Nodes

### RecordDeclaration
```kotlin
// Add to RecordDeclaration:
var recordComponents: List<RecordComponentDeclaration> = emptyList()
var isCompactConstructor: Boolean = false

// Add to ConstructorDeclaration (context):
var isCompactConstructor: Boolean = false
```

### Sealed Class Support
```kotlin
// Add to RecordDeclaration (or new Declaration interface):
var isSealed: Boolean = false
var permittedSubtypes: List<Type> = emptyList()
var isNonSealed: Boolean = false
```

### Modifier Semantics
```kotlin
// Current: modifiers: List<String>
// Problem: No semantic checking

// Option 1: Keep string list + add semantic boolean
var isSealed: Boolean = modifiers.contains("sealed")

// Option 2: Create ModifierSet enum (preferred)
enum class Modifier {
    PUBLIC, PRIVATE, PROTECTED,
    STATIC, FINAL, ABSTRACT,
    SEALED, NON_SEALED,  // NEW
    SYNCHRONIZED, VOLATILE,
    TRANSIENT, NATIVE, STRICT
}
var modifierSet: Set<Modifier> = emptySet()
```

## Mapping from JavaParser

JavaParser 3.x+ supports all these features. Current gaps:

| JavaParser Type | CPG Mapping | Status |
|-----------------|------------|--------|
| `RecordDeclaration` | RecordDeclaration | Partial |
| `RecordCompactConstructorDeclaration` | None | Missing |
| `SwitchExpr` | None | Missing |
| `YieldStmt` | None | Missing |
| `PatternExpr` | None | Missing |
| `TypePattern` | None | Missing |
| `RecordPattern` | None | Missing |
| `StringLiteralExpr` (text block) | Literal<String> | Undifferentiated |

## Phased Implementation Plan

### Phase 1: Records (Week 1-2)
Priority: HIGH
- [ ] Create RecordComponentDeclaration
- [ ] Update Java frontend handler
- [ ] Add Query API support
- [ ] Create tests

### Phase 2: Sealed Classes (Week 2-3)
Priority: HIGH
- [ ] Add isSealed, permittedSubtypes fields
- [ ] Update Java frontend parser
- [ ] Add permits clause processing
- [ ] Query support

### Phase 3: Switch Expressions (Week 3-4)
Priority: HIGH
- [ ] Create SwitchExpression (distinct from Statement)
- [ ] Create YieldStatement
- [ ] Handle arrow label syntax
- [ ] Type inference for switch expr

### Phase 4: Pattern Matching (Week 4-6)
Priority: CRITICAL
- [ ] Create PatternExpression hierarchy
- [ ] TypePatternExpression implementation
- [ ] RecordPatternExpression implementation
- [ ] Update instanceof handler
- [ ] Switch pattern matching integration

### Phase 5: Text Blocks (Week 6-7)
Priority: MEDIUM
- [ ] Create TextBlockLiteral
- [ ] Handle indentation normalization
- [ ] Escape sequence processing
- [ ] Tests

### Phase 6: Query API (Week 7+)
Priority: MEDIUM
- [ ] Add query methods for new nodes
- [ ] Pattern matching queries
- [ ] Record component queries
- [ ] Sealed class hierarchy queries

## Query Examples (After Implementation)

```kotlin
// Current: Cannot do these queries
// Future: After implementation

// Find all record types
val records = graph.nodes<RecordDeclaration>()
    .filter { it.recordComponents.isNotEmpty() }

// Find sealed class hierarchies
val sealedHierarchy = graph.nodes<RecordDeclaration>()
    .filter { it.isSealed }

// Find pattern matching code
val patternMatches = graph.nodes<TypePatternExpression>()
    .filter { it.bindingVariable != null }

// Find switch expressions
val switchExprs = graph.nodes<SwitchExpression>()
    .map { it.selector }

// Find text blocks
val textBlocks = graph.nodes<TextBlockLiteral>()
    .filter { it.isTextBlock }
```

## Impact on Analysis

### Security Analysis
- Cannot identify sealed class constraints
- Cannot track pattern binding in pattern matching
- Cannot analyze switch expression control flow correctly
- Cannot distinguish record component accessors

### Code Understanding
- Record structure incompletely represented
- Pattern matching logic opaque
- Switch expression semantics ambiguous
- No type safety in sealed hierarchies

### Refactoring Support
- Cannot identify auto-generated record accessors
- Cannot enforce sealed class permits constraints
- Cannot safely transform pattern matches
- Cannot correctly handle pattern binding

## Estimated Implementation Effort

| Feature | Nodes | Handler | Query API | Tests | Total |
|---------|-------|---------|-----------|-------|-------|
| Records | 6h | 8h | 6h | 4h | 24h |
| Sealed | 4h | 6h | 4h | 3h | 17h |
| Pattern Matching | 16h | 20h | 12h | 10h | 58h |
| Switch Expr | 8h | 10h | 6h | 4h | 28h |
| Text Blocks | 4h | 4h | 2h | 2h | 12h |
| **Total** | **38h** | **48h** | **30h** | **23h** | **139h** |

## Dependencies

```
Text Blocks (independent)
Local Var Type (independent)
Switch Expr
  ├── YieldStatement
  └── CaseExpressionEntry
Records
  └── RecordComponentDeclaration
Sealed Classes
  └── PermitsClause (part of RecordDeclaration)
Pattern Matching (depends on all above for full support)
  ├── PatternExpression
  ├── TypePatternExpression
  └── RecordPatternExpression (depends on Records)
```

## References

- **JavaParser Documentation**: [Patterns & Switch](https://javaparser.org/)
- **Java Language Spec**: JLS 14, 15, 16, 17
- **CPG Architecture**: sem-001, sem-002
- **Evaluation Report**: ep-024

---

**Last Updated**: 2025-11-13  
**Status**: Gap analysis complete, ready for implementation planning
