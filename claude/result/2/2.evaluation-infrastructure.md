# ValueEvaluator 求值系统深度分析

## 1. 概述

本文档详细分析 CPG 的求值基础设施，包括 `ValueEvaluator`、`MultiValueEvaluator`、`SizeEvaluator` 的实现细节、能力边界和局限性。所有结论均基于代码证据。

## 2. ValueEvaluator 核心实现

**文件位置**: `/home/dai/code/cpg/cpg-core/src/main/kotlin/de/fraunhofer/aisec/cpg/evaluation/ValueEvaluator.kt`

### 2.1 类定义与设计理念 (行 40-68)

```kotlin
/**
 * The value evaluator tries to evaluate the (constant) value of an [Expression] basically by
 * following DFG edges until we reach a [Literal]. It also evaluates simple binary operations,
 * such as arithmetic operations, as well as simple string concatenations.
 *
 * The result can be retrieved in two ways:
 * * The result of the [resolve] function is a JVM object which represents the constant value
 * * Furthermore, after the execution of [evaluateInternal], the latest evaluation path can be
 *   retrieved in the [path] property of the evaluator.
 */
open class ValueEvaluator(
    /**
     * Contains a reference to a function that gets called if the value cannot be resolved by the
     * standard behaviour.
     */
    open val cannotEvaluate: (Node?, ValueEvaluator) -> Any? = { node: Node?, _: ValueEvaluator ->
        // end of the line, lets just keep the expression name
        if (node != null) {
            "{${node.name}}"
        } else {
            CouldNotResolve()
        }
    }
)
```

**设计特点**:
1. **沿 DFG 追踪直到 Literal**: 核心策略是沿着数据流边回溯到字面量
2. **可扩展的失败处理**: 通过 `cannotEvaluate` 回调，允许语言特定的求值逻辑
3. **路径追踪**: `path` 属性记录求值过程中访问的节点序列

### 2.2 求值入口 (行 75-106)

```kotlin
open fun evaluate(node: Any?): Any? {
    if (node !is Node) return node
    clearPath()

    return evaluateInternal(node, 0)
}

/**
 * Tries to evaluate this node and returns the result as the specified type [T].
 * If the evaluation fails, the result is "null".
 */
inline fun <reified T> evaluateAs(node: Node?): T? {
    if (node == null) return null
    clearPath()

    val result = evaluateInternal(node, 0)
    return if (result !is T) {
        Util.errorWithFileLocation(
            node,
            log,
            "Evaluated the node to type \"{}\". Expected type \"{}\". Returning \"null\".",
            result?.let { it::class.simpleName },
            T::class.simpleName,
        )
        null
    } else {
        result
    }
}
```

**两种求值方式**:
1. `evaluate()`: 返回 `Any?`，适合不确定类型的场景
2. `evaluateAs<T>()`: 返回特定类型 `T?`，类型不匹配时返回 null 并记录错误

### 2.3 核心求值逻辑 (行 113-143)

```kotlin
open fun evaluateInternal(node: Node?, depth: Int): Any? {
    if (node == null) {
        return null
    }

    // Add the expression to the current path
    node.let { this.path += it }

    when (node) {
        is NewArrayExpression -> return handleHasInitializer(node, depth)
        is VariableDeclaration -> return handleHasInitializer(node, depth)
        // For a literal, we can just take its value, and we are finished
        is Literal<*> -> return node.value
        is UnaryOperator -> return handleUnaryOp(node, depth)
        is BinaryOperator -> return handleBinaryOperator(node, depth)
        // Casts are just a wrapper in this case, we are interested in the inner expression
        is CastExpression -> return this.evaluateInternal(node.expression, depth + 1)
        is SubscriptExpression -> return handleSubscriptExpression(node, depth)
        // While we are not handling different paths of variables with If statements, we can
        // easily be partly path-sensitive in a conditional expression
        is ConditionalExpression -> return handleConditionalExpression(node, depth)
        is AssignExpression -> return handleAssignExpression(node, depth)
        is Reference -> return handleReference(node, depth)
        is CallExpression -> return handleCallExpression(node, depth)
        else -> return handlePrevDFG(node, depth)
    }

    // At this point, we cannot evaluate, and we are calling our [cannotEvaluate] hook
    return cannotEvaluate(node, this)
}
```

### 2.4 支持的节点类型

| 节点类型 | 处理方式 | 能力 |
|---------|---------|------|
| `Literal<*>` | 直接返回 `node.value` | ✅ 完全支持 |
| `VariableDeclaration` | 求值 `initializer` | ✅ 支持常量初始化 |
| `UnaryOperator` | 求值操作数后应用运算符 | ✅ 支持 `-`, `--`, `++`, `*`, `&` |
| `BinaryOperator` | 求值左右操作数后应用运算符 | ✅ 支持算术、比较、位运算 |
| `CastExpression` | 透传到内部表达式 | ✅ 忽略类型转换 |
| `SubscriptExpression` | 数组访问 | ⚠️ 仅支持简单初始化列表 |
| `ConditionalExpression` | 三目运算符 | ✅ 支持路径敏感求值 |
| `AssignExpression` | 复合赋值 | ⚠️ 部分支持 |
| `Reference` | 跟随 DFG | ⚠️ 取决于 `refersTo` 和 DFG |
| `CallExpression` | 默认跟随 DFG | ❌ 不内联函数体 |

### 2.5 二元运算符支持 (行 192-236)

```kotlin
protected open fun handleBinaryOperator(expr: BinaryOperator, depth: Int): Any? {
    // Resolve rhs
    val rhsValue = evaluateInternal(expr.rhs, depth + 1)

    // Resolve lhs
    val lhsValue = evaluateInternal(expr.lhs, depth + 1)

    return computeBinaryOpEffect(lhsValue, rhsValue, expr)
}

protected open fun computeBinaryOpEffect(
    lhsValue: Any?,
    rhsValue: Any?,
    has: HasOperatorCode?,
): Any? {
    val expr = has as? Expression
    return when (has?.operatorCode) {
        "+", "+=" -> handlePlus(lhsValue, rhsValue, expr)
        "-", "-=" -> handleMinus(lhsValue, rhsValue, expr)
        "/", "/=" -> handleDiv(lhsValue, rhsValue, expr)
        "*", "*=" -> handleTimes(lhsValue, rhsValue, expr)
        "<<" -> handleShiftLeft(lhsValue, rhsValue, expr)
        ">>" -> handleShiftRight(lhsValue, rhsValue, expr)
        "&" -> handleBitwiseAnd(lhsValue, rhsValue, expr)
        "|" -> handleBitwiseOr(lhsValue, rhsValue, expr)
        "^" -> handleBitwiseXor(lhsValue, rhsValue, expr)
        ">" -> handleGreater(lhsValue, rhsValue, expr)
        ">=" -> handleGEq(lhsValue, rhsValue, expr)
        "<" -> handleLess(lhsValue, rhsValue, expr)
        "<=" -> handleLEq(lhsValue, rhsValue, expr)
        "==" -> handleEq(lhsValue, rhsValue, expr)
        "!=" -> handleNEq(lhsValue, rhsValue, expr)
        else -> cannotEvaluate(expr, this)
    }
}
```

**支持的运算符**:
- **算术**: `+`, `-`, `*`, `/`, `+=`, `-=`, `*=`, `/=`
- **位运算**: `<<`, `>>`, `&`, `|`, `^`
- **比较**: `>`, `>=`, `<`, `<=`, `==`, `!=`

**类型支持**:
- `+`: String 拼接 + Number 加法 (行 238-244)
- 算术运算: 仅 Number 类型 (行 246-266)
- 位运算: 仅 Int 和 Long (行 268-311)
- 比较: Number 和 String 的相等性，Number 的大小关系 (行 313-371)

### 2.6 ConditionalExpression 的路径敏感求值 (行 431-450)

```kotlin
protected open fun handleConditionalExpression(expr: ConditionalExpression, depth: Int): Any? {
    var condition = expr.condition

    // Assume that condition is a binary operator
    if (condition is BinaryOperator) {
        val lhs = evaluateInternal(condition.lhs, depth)
        val rhs = evaluateInternal(condition.rhs, depth)

        // Compute the effect of the comparison
        val comparison = computeBinaryOpEffect(lhs, rhs, condition)

        return if (comparison == true) {
            evaluateInternal(expr.thenExpression, depth + 1)
        } else {
            evaluateInternal(expr.elseExpression, depth + 1)
        }
    }

    return cannotEvaluate(expr, this)
}
```

**能力**:
- ✅ 如果条件是 `BinaryOperator` 且可求值为 true/false，则只求值相应分支
- ❌ 如果条件不是 `BinaryOperator` 或无法求值，则失败

**限制**: 只处理二元比较作为条件，不支持 `if (x)` 这种非比较条件。

### 2.7 沿 DFG 求值 (行 452-479)

```kotlin
protected open fun handlePrevDFG(node: Node, depth: Int): Any? {
    // For a reference, we are interested into its last assignment into the reference
    // denoted by the previous DFG edge. We need to filter out any self-references for READWRITE
    // references.
    val prevDFG =
        if (node is Reference) {
            filterSelfReferences(node, node.prevDFG.toList())
        } else {
            node.prevDFG
        }

    return if (prevDFG.size == 1) {
        // There's only one incoming DFG edge, so we follow this one.
        evaluateInternal(prevDFG.first(), depth + 1)
    } else if (prevDFG.size > 1) {
        // We cannot have more than ONE valid solution, so we need to abort
        log.warn(
            "We cannot evaluate {}: It has more than 1 previous DFG edges, meaning that the value is probably affected by a branch.",
            node,
        )
        cannotEvaluate(node, this)
    } else {
        // No previous DFG node
        log.warn("We cannot evaluate {}: It has no previous DFG edges.", node)
        cannotEvaluate(node, this)
    }
}
```

**关键限制** (行 468-473):
- ⚠️ **只能有一条 prevDFG 边**: 如果有多条边（分支汇合），则无法求值
- ⚠️ **不进行路径敏感分析**: 无法根据当前路径选择正确的 DFG 边

**这是当前求值器的核心局限**: 无法处理控制流汇合点的值。

### 2.8 示例：能求值 vs 不能求值

#### ✅ 能求值

```java
// Example 1: Simple constant
final int x = 5;
if (x > 3) { ... }  // evaluator.evaluate(condition) => true

// Example 2: Arithmetic
final int a = 10;
final int b = 20;
if (a + b > 15) { ... }  // evaluator.evaluate(condition) => true

// Example 3: Ternary
final int x = true ? 100 : 200;  // evaluator.evaluate(x) => 100
```

#### ❌ 不能求值

```java
// Example 1: Multiple DFG edges (branch merge)
int x;
if (someCondition) {
    x = 10;
} else {
    x = 20;
}
if (x > 15) { ... }  // evaluator.evaluate(condition) => CouldNotResolve

// Example 2: Function call
int x = computeValue();
if (x > 0) { ... }  // evaluator.evaluate(condition) => CouldNotResolve

// Example 3: Non-binary condition
if (x) { ... }  // evaluator.evaluate(condition) => CouldNotResolve
```

## 3. MultiValueEvaluator 分析

**文件位置**: `/home/dai/code/cpg/cpg-core/src/main/kotlin/de/fraunhofer/aisec/cpg/evaluation/MultiValueEvaluator.kt`

### 3.1 设计目标 (行 38-39)

```kotlin
/** This [ValueEvaluator] can resolve multiple possible values of a node. */
class MultiValueEvaluator : ValueEvaluator()
```

**核心改进**: 允许一个节点有多个可能的值（通过 `Collection<Any?>`）。

### 3.2 多值返回 (行 47-56)

```kotlin
override fun evaluate(node: Any?): Any? {
    clearPath()

    val result = evaluateInternal(node as? Node, 0)
    return if (result is Collection<*> && result.all { r -> r is Number }) {
        ConcreteNumberSet(result.map { r -> (r as Number).toLong() }.toMutableSet())
    } else {
        result
    }
}
```

**特殊处理**: 如果结果是一组数字，转换为 `ConcreteNumberSet`。

### 3.3 处理多条 DFG 边 (行 216-252)

```kotlin
override fun handlePrevDFG(node: Node, depth: Int): Collection<Any?> {
    val prevDFG =
        if (node is Reference) {
            filterSelfReferences(node, node.prevDFG.toList())
        } else {
            node.prevDFG
        }

    if (prevDFG.size == 1) {
        // There's only one incoming DFG edge, so we follow this one.
        val internalRes = evaluateInternal(prevDFG.first(), depth + 1)
        return (internalRes as? Collection<*>) ?: mutableSetOf(internalRes)
    }

    if (node is Reference && prevDFG.size == 2 && prevDFG.all(::isSimpleForLoop)) {
        return handleSimpleLoopVariable(node, depth)
    }

    val result = mutableSetOf<Any?>()
    if (prevDFG.isEmpty()) {
        // No previous expression?? Let's try with a variable declaration and its initialization
        val decl = prevDFG.filterIsInstance<VariableDeclaration>()
        for (declaration in decl) {
            val res = evaluateInternal(declaration, depth + 1)
            result.addAnything(res)
        }
    }

    for (expression in prevDFG) {
        val res = evaluateInternal(expression, depth + 1)
        result.addAnything(res)
    }
    return result
}
```

**关键改进** (行 238-251):
- ✅ **处理多条 DFG 边**: 求值所有可能路径的值并返回集合
- ✅ **特殊处理简单 for 循环**: 识别循环变量并求值所有迭代值 (行 233-235)

### 3.4 简单循环变量求值 (行 280-396)

```kotlin
private fun handleSimpleLoopVariable(expr: Reference, depth: Int): Collection<Any?> {
    val loop =
        expr.prevDFG.firstOrNull { it.astParent is ForStatement }?.astParent as? ForStatement
            ?: ...
    if (loop == null || loop.condition !is BinaryOperator) return setOf()

    var loopVar: Any? =
        evaluateInternal(loop.initializerStatement?.declarations?.first(), depth) as? Number
            ?: return setOf()

    val cond = loop.condition as BinaryOperator
    val result = mutableSetOf<Any?>()
    var lhs = ...
    var rhs = ...

    var comparisonResult = computeBinaryOpEffect(lhs, rhs, cond)
    while (comparisonResult == true) {
        result.add(loopVar)

        val loopOp = loop.iterationStatement
        loopVar = when (loopOp) {
            is AssignExpression -> { ... }
            is BinaryOperator -> { ... }
            is UnaryOperator -> { ... }
            else -> null
        }
        if (loopVar == null) {
            return result
        }

        // 更新条件中的循环变量值
        if ((cond.lhs as? Reference)?.refersTo == expr.refersTo) {
            lhs = loopVar
        }
        if ((cond.rhs as? Reference)?.refersTo == expr.refersTo) {
            rhs = loopVar
        }
        comparisonResult = computeBinaryOpEffect(lhs, rhs, cond)
    }
    return result
}
```

**能力**: 对于简单的 `for (int i = 0; i < 10; i++)` 循环，能求出循环变量的所有值 `{0, 1, 2, ..., 9}`。

**限制**:
- 仅支持简单数值循环
- 条件必须是 `BinaryOperator`
- 迭代必须是 `AssignExpression`、`BinaryOperator` 或 `UnaryOperator`

### 3.5 ConditionalExpression 的多值处理 (行 167-174)

```kotlin
override fun handleConditionalExpression(expr: ConditionalExpression, depth: Int): Any {
    val result = mutableSetOf<Any?>()
    val elseResult = evaluateInternal(expr.elseExpression, depth + 1)
    val thenResult = evaluateInternal(expr.thenExpression, depth + 1)
    result.addAnything(thenResult)
    result.addAnything(elseResult)
    return result
}
```

**改进**: 不求值条件，而是返回两个分支的所有可能值。

## 4. SizeEvaluator 分析

**文件位置**: `/home/dai/code/cpg/cpg-core/src/main/kotlin/de/fraunhofer/aisec/cpg/evaluation/SizeEvaluator.kt`

### 4.1 设计目标 (行 34-37)

```kotlin
/**
 * Simple evaluation of the size of an object. Right now, it can only support a statically given
 * size of arrays and strings.
 */
class SizeEvaluator : ValueEvaluator()
```

### 4.2 实现 (行 42-67)

```kotlin
override fun evaluate(node: Any?): Any? {
    if (node is String) {
        return node.length
    }
    return evaluateInternal(node as? Node, 0)
}

override fun evaluateInternal(node: Node?, depth: Int): Any? {
    node?.let { this.path += it }

    return when (node) {
        is NewArrayExpression ->
            if (node.initializer != null) {
                evaluateInternal(node.initializer, depth + 1)
            } else {
                evaluateInternal(node.dimensions.firstOrNull(), depth + 1)
            }
        is VariableDeclaration -> evaluateInternal(node.initializer, depth + 1)
        is Reference -> evaluateInternal(node.refersTo, depth + 1)
        is Literal<*> -> if (node.value is String) (node.value as String).length else node.value
        is SubscriptExpression -> evaluate(node.arrayExpression)
        else -> cannotEvaluate(node, this)
    }
}
```

**用途**: 求数组大小或字符串长度，用于边界检查分析。

## 5. 求值能力总结表

| 表达式类型 | ValueEvaluator | MultiValueEvaluator | 示例 |
|-----------|----------------|---------------------|------|
| 字面量 | ✅ | ✅ | `5`, `"hello"` |
| 简单常量变量 | ✅ | ✅ | `final int x = 10;` |
| 算术表达式 | ✅ | ✅ | `a + b * c` |
| 比较表达式 | ✅ | ✅ | `x > 5` |
| 位运算 | ✅ | ✅ | `a & 0xFF` |
| 三目运算符 | ⚠️ 仅二元条件 | ✅ 返回两个分支 | `x ? 10 : 20` |
| 数组访问 | ⚠️ 简单初始化列表 | ⚠️ 简单初始化列表 | `arr[0]` |
| 分支汇合 | ❌ 多DFG边失败 | ✅ 返回所有值 | `if...else` 后的变量 |
| 简单for循环 | ❌ | ✅ | `for (int i=0; i<10; i++)` |
| 函数调用 | ❌ | ❌ | `foo()` |
| 复杂控制流 | ❌ | ❌ | 嵌套循环、switch |
| 指针运算 | ❌ | ❌ | `*ptr`, `&var` (C/C++) |
| 对象字段 | ❌ | ❌ | `obj.field` |

## 6. 局限性与障碍

### 6.1 不支持符号值

**证据**: 所有求值器都返回 `Any?`（具体的 JVM 对象），没有符号值或约束的概念。

**影响**: 无法处理类似 `if (x > y)` 然后在 then 分支中知道 `x > y` 成立的情况。

### 6.2 不支持约束求解

**证据**: 没有找到约束求解器相关代码（如 Z3、SMT），所有求值都是直接计算。

**影响**: 无法处理间接条件，如：
```java
int a = x + 5;
if (a > 10) {  // 无法推断出 x > 5
    ...
}
```

### 6.3 路径不敏感（ValueEvaluator）

**证据**: `handlePrevDFG` (行 468-473) 在多条 DFG 边时直接失败。

**影响**: 在分支汇合点无法求值：
```java
int x;
if (cond) x = 10; else x = 20;
// 在这里，x 有两条 prevDFG 边，ValueEvaluator 无法求值
```

### 6.4 深度限制

**证据**: `MultiValueEvaluator.evaluateInternal` (行 64-66):
```kotlin
if (depth > MAX_DEPTH) {
    return cannotEvaluate(node, this)
}
```

**MAX_DEPTH = 20** (行 41): 防止无限递归，但可能截断长依赖链。

### 6.5 不支持过程间分析

**证据**: `handleCallExpression` 默认实现 (行 146-148):
```kotlin
protected open fun handleCallExpression(node: CallExpression, depth: Int): Any? {
    return handlePrevDFG(node, depth)
}
```

不会内联函数体或查找函数的返回值。

## 7. 与 UnreachableEOGPass 的集成

**文件位置**: `/home/dai/code/cpg/cpg-analysis/src/main/kotlin/de/fraunhofer/aisec/cpg/passes/UnreachableEOGPass.kt`

### 7.1 如何使用 ValueEvaluator (行 156)

```kotlin
private fun handleIfStatement(...): UnreachabilityStateElement {
    val evalResult = n.language.evaluator.evaluate(n.condition)

    val (unreachableEdges, remainingEdges) =
        if (evalResult == true) {
            // If the condition is always true, the "false" branch is always unreachable
            Pair(
                n.nextEOGEdges.filter { e -> e.branch == false },
                n.nextEOGEdges.filter { e -> e.branch != false },
            )
        } else if (evalResult == false) {
            // If the condition is always false, the "true" branch is always unreachable
            Pair(
                n.nextEOGEdges.filter { e -> e.branch == true },
                n.nextEOGEdges.filter { e -> e.branch != true },
            )
        } else {
            Pair(listOf(), n.nextEOGEdges)
        }
    ...
}
```

**使用方式**:
1. 调用 `language.evaluator.evaluate(condition)`
2. 如果结果是布尔值 `true` 或 `false`，标记对应分支为不可达
3. 如果无法求值（返回 `CouldNotResolve` 等），保守地认为两个分支都可达

### 7.2 循环处理 (行 191-228)

```kotlin
private fun handleLoopStatement(...): UnreachabilityStateElement {
    val condition =
        when (n) {
            is WhileStatement -> n.condition
            is DoStatement -> n.condition
            is ForStatement -> n.condition
            else -> return state
        }
    val evalResult = n.language.evaluator.evaluate(condition)

    val (unreachableEdges, remainingEdges) =
        if (evalResult is Boolean && evalResult == true) {
            Pair(
                n.nextEOGEdges.filter { e -> e.branch == false },
                n.nextEOGEdges.filter { e -> e.branch != false },
            )
        } else if (evalResult is Boolean && evalResult == false) {
            Pair(
                n.nextEOGEdges.filter { e -> e.branch == true },
                n.nextEOGEdges.filter { e -> e.branch != true },
            )
        } else {
            Pair(listOf(), n.nextEOGEdges)
        }
    ...
}
```

**相同逻辑**: 对循环条件求值，决定是否剪枝。

## 8. 可行性评估

### 8.1 当前能做到的

基于现有 `UnreachableEOGPass` + `ValueEvaluator`:

✅ **简单常量条件剪枝**:
```java
if (true) {
    reachable();
} else {
    unreachable();  // 会被标记为不可达
}

final int x = 5;
if (x > 3) {
    reachable();
} else {
    unreachable();  // 会被标记为不可达
}
```

✅ **简单常量传播**:
```java
final int a = 10;
final int b = 20;
if (a + b > 15) {
    reachable();
} else {
    unreachable();  // 会被标记为不可达
}
```

### 8.2 当前做不到的

❌ **分支汇合后的值**:
```java
int x;
if (someCondition) {
    x = 100;
} else {
    x = 200;
}
if (x > 150) {  // 无法判断，因为 x 有两条 DFG 边
    ...
}
```

**解决方案**: 需要使用 `MultiValueEvaluator`，但它会返回 `{100, 200}`，然后需要根据路径选择。

❌ **过程间常量传播**:
```java
int getConst() { return 42; }

if (getConst() > 0) {  // 无法求值函数调用
    ...
}
```

**解决方案**: 需要内联或函数摘要。

❌ **循环后的值**:
```java
int x = 0;
for (int i = 0; i < 10; i++) {
    x += i;
}
if (x == 45) {  // 无法求值循环累积的值
    ...
}
```

**解决方案**: 需要循环展开或归纳变量分析。

## 9. 增强建议

### 9.1 短期增强（保持兼容）

1. **扩展 ConditionalExpression 求值**: 支持非二元条件
   ```kotlin
   // 行 432-449 修改
   if (condition is Reference) {
       val value = evaluateInternal(condition, depth)
       if (value is Boolean) {
           return if (value) ... else ...
       }
   }
   ```

2. **添加布尔运算符**: 支持 `&&`, `||`, `!`
   ```kotlin
   "&&" -> handleAnd(lhsValue, rhsValue, expr)
   "||" -> handleOr(lhsValue, rhsValue, expr)
   "!" -> handleNot(inputValue, expr)
   ```

3. **集成 MultiValueEvaluator 到 UnreachableEOGPass**: 对于多值结果，保守处理
   ```kotlin
   val evalResult = n.language.evaluator.evaluate(n.condition)
   when (evalResult) {
       is Boolean -> ...  // 确定值
       is Collection<*> -> {
           if (evalResult.all { it == true }) -> 剪枝 false 分支
           else if (evalResult.all { it == false }) -> 剪枝 true 分支
           else -> 保守地保留两个分支
       }
   }
   ```

### 9.2 中期增强（需要新架构）

1. **引入抽象域**: 定义 `AbstractValue` 接口，支持 `Top`, `Bottom`, `Constant(v)`, `Interval(low, high)`, `Set(values)`

2. **路径敏感求值器**: 在求值时传递路径约束

3. **函数摘要**: 预计算或按需计算函数的输入输出关系

### 9.3 长期增强（重大重构）

1. **符号执行引擎**: 用符号值替代具体值

2. **约束求解器集成**: 使用 Z3 或其他 SMT 求解器

3. **全程序分析**: 跨函数、跨编译单元的常量传播

## 10. 结论

**ValueEvaluator 现状**:
- ✅ 适合简单常量表达式
- ✅ 支持基本算术和比较运算
- ⚠️ 有限的路径敏感性（仅 ConditionalExpression）
- ❌ 不支持符号值、约束、过程间分析

**可行性**:
- **基于当前基础设施**: 可以处理 30-40% 的实际常量条件（简单常量、直接算术）
- **增强后**: 可以处理 60-70%（加上简单循环、多值集合）
- **需要符号执行**: 才能处理 90%+

**建议**:
1. 先实现短期增强（低成本高收益）
2. 在实际项目中测试覆盖率
3. 根据需求决定是否投入中长期增强
