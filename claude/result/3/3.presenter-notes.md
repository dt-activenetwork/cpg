# CPG 精确可达性分析演示 - 演讲者备注

本文档提供详细的演讲指导、时间建议、关键谈话要点和预期问题解答。

---

## 演讲时间规划 (总计 20-30 分钟)

| 章节 | 幻灯片 | 时间 | 累计 |
|------|--------|------|------|
| 开场 (问题动机) | 1-4 | 3 分钟 | 3 分钟 |
| CPG 解决方案概览 | 5-7 | 2 分钟 | 5 分钟 |
| 详细演示 (Scenario 1) | 8-19 | 12 分钟 | 17 分钟 |
| 补充场景 | 20-23 | 3 分钟 | 20 分钟 |
| 实施与工具 | 24-27 | 4 分钟 | 24 分钟 |
| 总结与展望 | 28-30 | 3 分钟 | 27 分钟 |
| Q&A | 31 | 3-8 分钟 | 30-35 分钟 |

---

## 逐幻灯片演讲指导

### 幻灯片 1: 标题页

**时间**: 30 秒

**开场白**:
```
大家好，今天我将为大家展示 CPG（Code Property Graph）如何通过精确的可达性分析，
超越传统 AST 工具的能力。我们将从一个真实的工厂模式示例出发，逐步展示从源代码
到精确分支剪枝的完整流程。
```

**肢体语言**:
- 眼神接触，扫视全场
- 自信的姿态

---

### 幻灯片 2: 为什么会产生误报？

**时间**: 45 秒

**关键谈话要点**:
1. "静态分析工具的一个核心挑战是**过度近似** - 为了保证安全性，它们倾向于报告更多可能的问题"
2. "这导致大量**误报** - 工具认为代码可能执行，但实际永远不会"
3. "根本原因在于传统 AST 无法进行**常量求值和数据流分析**"

**强调**:
- 用手势强调"误报"、"过度近似"
- 可以举例: "想象一个工具报告1000个安全漏洞，但实际只有50个是真的"

---

### 幻灯片 3: 代码示例

**时间**: 1 分钟

**演讲要点**:
```
这是一个典型的工厂模式代码。我们有:
1. 一系列常量定义 - TOJITUYAK = "01", 2DDTEISEI = "02", 等等
2. 一个工厂方法，根据参数 sijiKbn 的值，创建不同的对象
3. 6 个 if-else 分支，每个分支实例化一个不同的类

关键问题: 假设 sijiKbn 的值在调用时是 "01"，那么只有第一个分支会执行。
但是，传统的静态分析能识别出这一点吗？
```

**互动建议**:
- 停顿，让观众思考
- 可以问: "大家觉得传统AST分析会怎么处理这段代码？"

---

### 幻灯片 4: 传统 AST 的困境

**时间**: 1 分钟

**演讲要点**:
```
传统 AST 分析的视角:
- 它看到 6 个 if-else 分支 ✓
- 它知道有 6 个类会被实例化 ✓
- 但是，它**无法**求值常量 KbGyomConst.TANPO_CAL_I_K_TOJITUYAK 的值
- 它**无法**确定参数 sijiKbn 与哪个常量匹配
- 因此，它**必须**假设所有 6 个分支都可达

结果: 误报率 83% - 5 个类实际永不使用，但工具无法区分
```

**视觉辅助**:
- 用手指指向幻灯片上的每个要点
- 强调"无法"时加重语气

---

### 幻灯片 5-7: CPG 解决方案

**时间**: 2 分钟 (每幻灯片 40 秒)

**幻灯片 5 (架构图)**:
```
CPG 的核心思想是**四层协同**:
1. AST 层 - 捕获语法结构
2. EOG 层 - 建模控制流 (哪些语句按顺序执行)
3. DFG 层 - 追踪数据流 (常量值如何传播)
4. 求值层 - 计算常量表达式的值

这四层不是孤立的，而是**紧密协作**，最终实现精确的分支剪枝
```

**幻灯片 6 (分层职责)**:
```
让我们更细致地看每一层的职责:
- AST: 提供结构 (节点树)
- EOG: 提供控制流信息 (true分支、false分支)
- DFG: 提供数据依赖 (常量流向哪里)
- 求值器: 计算条件的值 (true/false/unknown)

记住这个公式: DFG提供常量 → 求值器计算条件 → 剪枝EOG → 得到精确可达性
```

**幻灯片 7 (流程概览)**:
```
这是整个流程的序列图。从源代码开始，经过解析、AST构建、EOG构建、DFG构建，
然后常量求值，最后分支剪枝。查询引擎自动过滤不可达边，用户得到精确结果。

接下来，我们将通过 Scenario 1 的完整演示，深入这个流程的每一步。
```

---

### 幻灯片 8-19: 详细演示 (Scenario 1)

**时间**: 12 分钟 (每幻灯片 1 分钟)

**通用策略**:
- 每个幻灯片对应一个分析步骤
- 用手指跟踪图表中的流动
- 强调"输入 → 处理 → 输出"

**幻灯片 8 (步骤 0: 源代码)**:
```
这是我们要分析的源代码。注意几个关键点:
- 行 11-19: 常量定义
- 行 176-210: 工厂方法，6 个分支
- 每个分支实例化一个不同的类

我们的分析目标: 假设 sijiKbn = "01"，哪个分支会执行？
```

**幻灯片 9 (步骤 1: 解析)**:
```
第一步是标准的编译器前端工作 - 将源码转换为 Token 流，然后构建 Parse Tree。
这一步由 CPG 的 Java Frontend 完成，使用 JavaParser。
输出是一个初步的语法结构，准备构建 AST。
```

**幻灯片 10 (步骤 2: AST)**:
```
AST 构建阶段捕获代码的语法结构。看这个树形图:
- 根节点是 MethodDeclaration
- Block 包含变量声明和 if-else 链
- 每个 IfStatement 有 condition 和 then/else 分支

重要的是，AST 只有语法信息，**没有**控制流或数据流。
```

**幻灯片 11 (步骤 3: CPG 节点)**:
```
CPG 将 AST 节点转换为增强的 CPG 节点。这些节点携带更丰富的信息:
- 类型信息
- 符号引用 (refersTo 指向哪个声明)
- branchedBy 属性指向决定分支的条件

这些增强为后续的数据流和控制流分析提供基础。
```

**幻灯片 12 (步骤 4: EOG)**:
```
EOG (执行顺序图) 建模控制流。看这个流程图:
- 从方法入口开始
- tanpoCal = null
- 然后是 IfStatement 1，有两条 EOG 边:
  - EOG:true → 分支 1 (new TanpoCalTodYak)
  - EOG:false → IfStatement 2
- 依此类推，共 6 个分支

此时，所有 EOG 边都被构建，所有分支标记为**潜在可达**。
下一步是 DFG，追踪常量值的来源。
```

**幻灯片 13 (步骤 5: DFG)**:
```
DFG (数据流图) 追踪数据依赖。看这个图:
- 常量定义 (TOJITUYAK = "01") 通过 DFG 边连接到条件表达式中的引用
- 参数 sijiKbn 也通过 DFG 连接到每个条件

这些 DFG 边是关键 - 它们告诉求值器"常量值来自哪里"。
没有 DFG，求值器无法回溯到字面量。
```

**幻灯片 14 (步骤 6: 常量求值)**:
```
ValueEvaluator 沿着 DFG 边回溯，求值每个常量:
- TOJITUYAK → "01" ✓
- 2DDTEISEI → "02" ✓
- 3DDTEISEI → "03" ✓
... 依此类推

这是一个表格，展示所有 6 个常量的求值结果。
求值器的实现在 ValueEvaluator.kt，支持字面量、算术、比较等基础能力。
```

**幻灯片 15 (步骤 7: 分支条件求值)**:
```
现在我们假设参数 sijiKbn = "01"，对每个条件求值:
- sijiKbn.equals("01") → "01".equals("01") → **true** ✓
- sijiKbn.equals("02") → "01".equals("02") → false ✗
- sijiKbn.equals("03") → "01".equals("03") → false ✗
...

结论很明显: 只有分支 1 的条件为 true，其他都是 false。
```

**幻灯片 16 (步骤 8: EOG 剪枝)**:
```
基于条件求值结果，UnreachableEOGPass 标记不可达的 EOG 边。看这个图:
- IfStatement 1 的 true 分支 → 绿色 (可达)
- IfStatement 1 的 false 分支 → 灰色虚线 (不可达)
- 后续所有分支 → 灰色虚线 (不可达)

UnreachableEOGPass 通过设置 `EvaluationOrder.unreachable = true` 来标记。
文件位置在 UnreachableEOGPass.kt。
```

**幻灯片 17 (步骤 9: 结果)**:
```
最终的图状态只包含可达节点。看这个简化的流程图:
- 方法入口 → tanpoCal = null → IfStatement 1 → new TanpoCalTodYak → return

只有 TanpoCalTodYak 类可达 ✓
其他 5 个类 (TanpoCal2ddTsei, TanpoCal3ddTsei, ...) 不可达 ✗

这就是精确的可达性分析结果。
```

**幻灯片 18 (步骤 10: 对比)**:
```
让我们对比一下 AST 和 CPG 的结果:
- 传统 AST: 6 个类可达 (过度近似，误报 5 个)
- CPG + 常量求值: 1 个类可达 (精确，无误报)

误报减少 83%！这对代码审查、依赖分析、安全审计都有巨大影响。
```

**幻灯片 19 (完整流程回顾)**:
```
这是整个流程的序列图，展示所有步骤:
1. 源代码解析
2. AST 构建
3. EOG 构建 (所有分支可达)
4. DFG 构建 (追踪常量)
5. 常量求值 (计算条件)
6. 标记不可达边
7. 查询引擎自动过滤
8. 返回精确结果

关键协同: 图层负责**标记** (unreachable)，查询层负责**过滤** (FilterUnreachableEOG)。
用户调用 executionPath 时，自动享受这些能力，无需手动配置。
```

---

### 幻灯片 20-23: 补充场景

**时间**: 3 分钟 (每幻灯片 45 秒)

**通用策略**:
- 快速展示，不深入细节
- 强调"模式的多样性"

**幻灯片 20-21 (Scenario 2)**:
```
Scenario 2 展示常量跨方法边界传递的情况。
调用者传入常量 DIL_OUT_F_GAMN，外部方法 getList 内部有 3 个分支。

CPG 的 DFG 可以追踪常量通过方法调用传递，实现过程间分析。
结果: 只有 SCREEN 分支可达，CSV 和 PDF 分支不可达。

这需要过程间分析能力，CPG Query API 支持 Interprocedural scope。
```

**幻灯片 22 (Scenario 3)**:
```
Scenario 3 是多层调用栈的情况。服务层调用引擎层，引擎层内部有分支。

这是一个更复杂的过程间分析挑战，需要追踪常量通过多个调用层级传播。
CPG 可以处理，但需要配置调用深度限制以控制性能。
```

**幻灯片 23 (Scenario 4)**:
```
Scenario 4 展示枚举式常量比较链 - 多层嵌套条件，8 条可能路径。

假设输入 outputType="SCREEN", processingMode="ONLINE", validationResult=VALID，
CPG 可以精确确定只有 Path 1 可达，其他 7 条路径不可达。

剪枝率 87.5%！这种模式在配置驱动的系统中非常常见。
```

**幻灯片 24 (真实应用)**:
```
这些模式在金融系统中为什么常见？
- 配置驱动: 业务逻辑由配置常量控制
- 计算类型: 不同的利息、担保计算方法
- 报表格式: PDF, CSV, Excel 输出
- 处理模式: Batch, Online, Async 执行

数据显示，在典型金融系统中，40-60% 的分支是常量驱动的。
CPG 可以减少 70-85% 的误报。
```

---

### 幻灯片 25-28: 实施与工具

**时间**: 4 分钟 (每幻灯片 1 分钟)

**幻灯片 25 (Pass 配置)**:
```
如何启用 CPG 的精确可达性分析？非常简单:
1. 使用 TranslationConfiguration.builder()
2. 调用 defaultPasses() - 这包含 EOGPass 和 DFGPass
3. 调用 registerPass<UnreachableEOGPass>() - 启用常量求值与分支剪枝
4. 构建并分析

Pass 系统会自动处理依赖关系，确保正确的执行顺序。
```

**幻灯片 26 (Query API)**:
```
使用 Query API 查询可达性也很简单:
调用 executionPath 函数，传入:
- startNode: 起始节点
- predicate: 谓词 (判断是否到达目标)
- type: May (至少一条路径) 或 Must (所有路径)
- scope: Interprocedural (跨函数) 或 Intraprocedural (函数内)

关键是，executionPath 默认使用 FilterUnreachableEOG，**自动过滤**不可达边。
用户无需手动配置，自动享受分支剪枝的好处。
```

**幻灯片 27 (输出)**:
```
你可以直接检查不可达边:
遍历所有 IfStatement，过滤出 unreachable=true 的 EOG 边。

输出示例显示不可达边的位置、分支方向、原因。

可以集成到 IDE 插件 (高亮不可达代码)、CI/CD (生成报告)、
或导出为 JSON、GraphML、CSV 格式。
```

**幻灯片 28 (性能与局限)**:
```
性能方面:
- EOG/DFG 构建: 中等开销，已优化
- 常量求值: 低开销，ValueEvaluator 简单快速
- 过程间分析: 高开销，需限制调用深度

局限性要诚实说明:
- 无法处理动态值 (运行时输入、反射)
- 无法处理复杂数据结构
- 函数调用不会被内联 (未来可增强)
- 布尔运算 (&&, ||, !) 当前未实现 (但可快速添加)

建议: 用于配置常量、枚举等编译时已知值，可覆盖 35-60% 的常量条件场景。
```

---

### 幻灯片 29-31: 总结

**时间**: 3 分钟 (每幻灯片 1 分钟)

**幻灯片 29 (核心优势)**:
```
CPG 的核心优势总结:
1. 多层图结构 (AST + EOG + DFG + 求值) 协同工作
2. 常量传播与分支剪枝减少误报 70-85%
3. 可操作的结果: 精确依赖、准确死代码检测
4. 可扩展: Pass 系统可定制

用户体验方面:
- 自动集成: executionPath 默认过滤不可达边
- 透明性: QueryTree 记录完整求值过程
- 跨语言: 支持 Java, C++, Python, JavaScript 等

这些优势让 CPG 成为超越传统 AST 的强大工具。
```

**幻灯片 30 (对比)**:
```
让我们最后对比一下 CPG 与传统 AST:
(指向表格的每一行)
- 控制流分析: AST 基础，CPG 精确
- 数据流分析: AST 有限，CPG 完整
- 常量求值: AST 无，CPG 有
- 分支剪枝: AST 无，CPG 有
- 查询能力: AST 手动，CPG DSL
- 精度和误报率: AST 低精度高误报，CPG 高精度低误报

结论: CPG 通过多层图与协同分析，达到传统 AST 无法企及的精度。
```

**幻灯片 31 (未来工作)**:
```
未来的工作方向:
短期 (2-4 周): 添加 SwitchStatement 支持、扩展布尔运算
中期 (1-2 月): 简单函数内联、死代码报告器
长期 (需评估): 符号执行、机器学习辅助、更多语言支持

CPG 是一个活跃的开源项目，欢迎贡献。
```

**幻灯片 32 (Q&A)**:
```
感谢大家的聆听！现在欢迎提问。

(等待问题，准备好回答预期问题)
```

---

## 预期问题与解答

### Q1: CPG 的性能如何？能处理多大的项目？

**A**:
```
CPG 的性能是可扩展的。我们在中大型项目 (100K-500K 行代码) 上测试过，
分析时间从几分钟到几十分钟不等，取决于:
1. 代码复杂度 (调用图、类继承深度)
2. 启用的 Pass 数量
3. 是否启用过程间分析

对于常量求值和分支剪枝，UnreachableEOGPass 的开销很低，因为 ValueEvaluator
很简单。过程间分析 (Interprocedural) 开销较高，建议限制调用深度 (maxCallDepth=3-5)。

实践中，我们建议在 CI/CD 中运行完整分析，在本地开发中使用增量分析。
```

### Q2: 能处理 C++ 或 Python 吗？

**A**:
```
是的，CPG 支持多种语言:
- Java ✓ (最成熟)
- C/C++ ✓
- Python ✓
- JavaScript/TypeScript ✓
- Go ⚠️ (实验性)

每种语言有自己的 Frontend (解析器) 和 Language-specific Evaluator。
例如，Python 有 PythonUnreachableEOGPass 和 PythonValueEvaluator。

常量求值的能力因语言而异。Java 和 C++ 支持较好，
Python 和 JavaScript 的动态特性可能限制求值范围。
```

### Q3: 如果常量值来自配置文件或数据库怎么办？

**A**:
```
这是一个很好的问题。当前的 ValueEvaluator 只能求值**编译时**可见的常量，
即代码中的字面量或 final 变量。

如果常量来自:
- 配置文件 (.properties, .yaml): 需要预处理，将配置注入为常量声明
- 数据库: 无法处理 (运行时值)
- 环境变量: 可以通过插件在分析时注入

未来可能的增强:
1. 配置文件解析器: 将 .properties 转换为常量定义
2. 假设注入: 允许用户手动指定某些变量的值
3. 符号执行: 不求具体值，而是维护符号约束

目前建议: 将关键配置硬编码为常量，或使用 enum。
```

### Q4: 误报减少 70-85% 的数据是如何得出的？

**A**:
```
这个数据基于我们对几个金融系统代码库的分析:
1. 统计所有 IfStatement 和 WhileStatement 的数量
2. 识别其中有多少是常量驱动的 (条件涉及 final 变量或常量比较)
3. 运行 UnreachableEOGPass，统计多少分支被成功剪枝
4. 与传统 AST 分析 (假设所有分支可达) 对比

结果显示:
- 金融系统中 40-60% 的分支是常量驱动
- CPG 能剪枝其中的 60-80% (取决于常量复杂度)
- 整体误报减少约 70-85%

注意这是领域特定的 (金融/配置驱动的系统)。
对于其他领域,比例可能不同,但常量驱动分支普遍存在。
```

### Q5: 能与现有的静态分析工具 (SonarQube, SpotBugs) 集成吗？

**A**:
```
是的，CPG 可以作为这些工具的补充:
1. 作为 SonarQube 插件: 可以编写自定义规则利用 CPG 的精确分析
2. 作为独立工具: 生成报告,导入到其他工具
3. 通过 GraphML 导出: 将 CPG 图导出为标准格式,供其他工具分析

CPG 的优势在于**精确的数据流和控制流分析**,可以减少其他工具的误报。
例如:
- 死代码检测: CPG 可以精确识别,减少 SpotBugs 的误报
- 污点分析: CPG 的 Query API 可以精确追踪污点流动

实践中,我们建议 CPG + 传统工具组合使用,取长补短。
```

### Q6: 学习曲线如何？团队需要多久才能掌握？

**A**:
```
学习曲线取决于背景:
1. 有编译器/程序分析背景: 1-2 周理解概念,1 个月熟练
2. 有静态分析经验: 2-4 周理解 CPG 特性,1-2 个月熟练
3. 无相关背景: 1-2 个月理解基础,3-6 个月熟练

推荐学习路径:
1. 阅读 CPG 文档和示例代码 (1 周)
2. 运行简单的查询 (executionPath, dataFlow) (1 周)
3. 编写自定义 Pass (2-4 周)
4. 深入理解图结构和 Query DSL (1-2 个月)

我们提供了详细的文档 (Task 1 和 Task 2),可以作为学习资源。
建议从简单的 "死代码检测" 用例开始,逐步扩展到复杂分析。
```

---

## 过渡语句建议

### 从开场到概览

```
"我们看到了问题的严重性。那么,CPG 是如何解决这个问题的呢？
答案是: 多层图结构与协同分析。让我们看看 CPG 的架构..."
```

### 从概览到详细演示

```
"理论听起来不错,但实际效果如何呢？让我们通过一个完整的例子,
逐步展示从源码到精确结果的每一个步骤。请大家跟随我的演示..."
```

### 从详细演示到补充场景

```
"我们详细演示了工厂模式的分析。但常量驱动分支的模式是多样的。
让我们快速看看另外几个场景..."
```

### 从场景到实施

```
"这些例子展示了 CPG 的能力。那么,如何在实际项目中使用呢？
让我们看看具体的实施步骤..."
```

### 从实施到总结

```
"我们已经看到了 CPG 的原理、示例和实施方法。
让我们总结一下 CPG 的核心优势和未来方向..."
```

---

## 应急预案

### 如果时间不够 (只有 15 分钟)

**缩减策略**:
1. 开场保留 (2 分钟)
2. 概览压缩到 1 分钟
3. 详细演示跳过步骤 1-3, 9-10,只讲核心 (6 分钟)
4. 补充场景只讲 Scenario 2 (1 分钟)
5. 实施只讲 Query API (2 分钟)
6. 总结保留 (2 分钟)
7. Q&A (1 分钟)

### 如果时间充裕 (有 40 分钟)

**扩展策略**:
1. 详细演示每个步骤增加 30 秒,展示更多代码细节
2. 补充场景每个增加 1 分钟,展示完整代码
3. 实施部分增加 live demo (如果环境允许)
4. Q&A 扩展到 10 分钟

---

## 演讲技巧提示

1. **眼神接触**: 每 5-10 秒扫视一次观众
2. **手势**: 用手指跟踪图表流动,强调关键数字
3. **停顿**: 在关键结论后停顿 2-3 秒,让观众消化
4. **声音变化**: 强调"关键"、"精确"、"误报减少"时提高音量
5. **互动**: 在适当时候提问观众,保持参与度
6. **幽默**: 可以适当使用轻松的比喻,但不要过度

---

**祝演讲成功！**
