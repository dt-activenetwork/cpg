# CPG Java 17 支持 - 核心改进实施方案

**重要前提**: Java前端需用Eclipse JDT重写，本方案聚焦CPG核心改进

## 一、快速修复清单（1周内完成）

### 1.1 D1: Static Final Field DFG (4-6小时) ⭐最高优先级

**文件**: `cpg-core/src/main/kotlin/de/fraunhofer/aisec/cpg/passes/DFGPass.kt`

**当前代码** (line 210-230):
```kotlin
fun handleMemberExpression(node: MemberExpression) {
    node.base?.let { base ->
        node.addPrevDFG(base)  // 只连接到base对象
    }
    // 缺失: 连接到FieldDeclaration
}
```

**修复方案**:
```kotlin
fun handleMemberExpression(node: MemberExpression) {
    node.base?.let { base ->
        node.addPrevDFG(base)
    }

    // 新增: 连接到静态字段声明
    val field = node.refersTo as? FieldDeclaration
    if (field?.modifiers?.contains("static") == true &&
        field.modifiers.contains("final")) {
        field.initializer?.let { init ->
            node.addPrevDFG(init)  // 添加从初始化器的数据流边
        }
    }
}
```

**验证测试**:
```java
public class Constants {
    public static final String CONFIG = "production";

    public void process() {
        if (CONFIG.equals("production")) {  // 现在可以求值
            // dead code elimination应该工作
        }
    }
}
```

### 1.2 修复var类型推断 (3-5天)

**文件**: `cpg-language-java/src/main/kotlin/de/fraunhofer/aisec/cpg/frontends/java/JavaLanguageFrontend.kt`

**当前问题** (line 248, 260):
- 检测到var但返回UnknownType
- 没有实际的类型推断逻辑

**修复方案**:
```kotlin
// 在JavaLanguageFrontend中添加
private fun inferVarType(node: VariableDeclarator): Type {
    val initializer = node.initializer ?: return UnknownType.getUnknownType(language)

    return when (initializer) {
        is NewExpression -> initializer.type
        is MethodCallExpression -> initializer.returnType
        is LiteralExpression -> initializer.type
        is BinaryOperator -> propagateTypeOfBinaryOperation(
            initializer.operatorCode,
            initializer.lhs.type,
            initializer.rhs.type
        )
        else -> initializer.type
    }
}
```

**优先级**: P0 - 影响所有使用var的现代Java代码

---

## 二、核心节点扩展（2-3周）

### 2.1 RecordComponentDeclaration节点

**新建文件**: `cpg-core/src/main/kotlin/de/fraunhofer/aisec/cpg/graph/declarations/RecordComponentDeclaration.kt`

```kotlin
/**
 * Represents a record component in Java 14+ records
 * Different from FieldDeclaration as it generates accessor methods
 */
class RecordComponentDeclaration : ValueDeclaration() {

    /** The generated accessor method */
    var accessorMethod: MethodDeclaration? = null

    /** Whether this component participates in equals/hashCode */
    var participatesInEquality: Boolean = true

    /** Position in the canonical constructor */
    var componentIndex: Int = -1

    override fun toString(): String {
        return "RecordComponent[$name: $type]"
    }
}
```

**集成到DeclarationHandler**:
```kotlin
// cpg-language-java/.../DeclarationHandler.kt
fun handleRecordDeclaration(record: RecordDeclaration) {
    // 处理record components
    for ((index, param) in record.parameters.withIndex()) {
        val component = RecordComponentDeclaration()
        component.name = param.name
        component.type = param.type
        component.componentIndex = index

        // 自动生成accessor
        val accessor = MethodDeclaration()
        accessor.name = param.name
        accessor.returnType = param.type
        component.accessorMethod = accessor

        record.addField(component)
        record.addMethod(accessor)
    }
}
```

### 2.2 PatternExpression节点体系

**新建文件**: `cpg-core/src/main/kotlin/de/fraunhofer/aisec/cpg/graph/statements/expressions/PatternExpression.kt`

```kotlin
/**
 * Base class for all pattern expressions in Java 14+
 */
abstract class PatternExpression : Expression() {
    /** Variables bound by this pattern */
    val boundVariables = mutableListOf<VariableDeclaration>()
}

/**
 * Type test pattern: instanceof Type variable
 */
class TypeTestPattern : PatternExpression() {
    var testedType: Type? = null
    var variable: VariableDeclaration? = null

    init {
        variable?.let { boundVariables.add(it) }
    }
}

/**
 * Guarded pattern: pattern when condition
 */
class GuardedPattern : PatternExpression() {
    var pattern: PatternExpression? = null
    var guard: Expression? = null

    override val boundVariables: List<VariableDeclaration>
        get() = pattern?.boundVariables ?: emptyList()
}
```

### 2.3 SwitchExpression vs SwitchStatement

**修改**: 区分表达式和语句形式

```kotlin
// 新建: cpg-core/.../expressions/SwitchExpression.kt
class SwitchExpression : Expression() {
    var selector: Expression? = null
    val cases = mutableListOf<SwitchCase>()

    /** The type of the switch expression result */
    override val type: Type
        get() = cases.mapNotNull { it.yieldValue?.type }
            .reduce { acc, type -> commonSuperType(acc, type) }
}

// 新增: YieldStatement
class YieldStatement : Statement() {
    var value: Expression? = null
    var enclosingSwitch: SwitchExpression? = null
}
```

---

## 三、类型系统增强（2周）

### 3.1 RecordType

```kotlin
// cpg-core/.../types/RecordType.kt
class RecordType : ObjectType() {
    /** Components of this record */
    val components = mutableListOf<RecordComponent>()

    /** Whether this record is extensible (non-sealed) */
    var isExtensible: Boolean = false

    data class RecordComponent(
        val name: String,
        val type: Type,
        val index: Int
    )

    override fun equals(other: Any?): Boolean {
        if (other !is RecordType) return false
        return super.equals(other) &&
               components == other.components
    }
}
```

### 3.2 SealedType层次

```kotlin
// cpg-core/.../types/SealedType.kt
class SealedType : ObjectType() {
    /** Permitted subtypes */
    val permittedSubtypes = mutableSetOf<Type>()

    /** Check if a type is permitted */
    fun isPermitted(type: Type): Boolean {
        return permittedSubtypes.contains(type) ||
               permittedSubtypes.any { it.isAncestorOf(type) }
    }

    /** Verify exhaustiveness */
    fun checkExhaustiveness(coveredTypes: Set<Type>): Boolean {
        return permittedSubtypes.all { permitted ->
            coveredTypes.any { covered ->
                covered == permitted || covered.isAncestorOf(permitted)
            }
        }
    }
}
```

---

## 四、Pass系统更新（3周）

### 4.1 PatternResolutionPass

**新建Pass处理Pattern变量的作用域**:

```kotlin
@DependsOn(SymbolResolver::class)
class PatternResolutionPass : ComponentPass() {

    override fun accept(component: Component) {
        component.walk { node ->
            when (node) {
                is InstanceOfExpression -> handleInstanceOf(node)
                is SwitchExpression -> handleSwitchPatterns(node)
            }
        }
    }

    private fun handleInstanceOf(node: InstanceOfExpression) {
        val pattern = node.pattern as? TypeTestPattern ?: return
        pattern.variable?.let { variable ->
            // 注册pattern变量到正确的作用域
            val scope = findPatternScope(node)
            scope.addDeclaration(variable)

            // 创建数据流边
            node.operand?.let { operand ->
                variable.addPrevDFG(operand)
            }
        }
    }
}
```

### 4.2 RecordPass

**处理Record特殊语义**:

```kotlin
@DependsOn(TypeResolver::class)
class RecordPass : ComponentPass() {

    override fun accept(component: Component) {
        component.records.forEach { record ->
            if (record.isRecord) {
                generateRecordMethods(record)
                processCompactConstructor(record)
            }
        }
    }

    private fun generateRecordMethods(record: RecordDeclaration) {
        // 自动生成equals/hashCode/toString
        if (record.methods.none { it.name == "equals" }) {
            val equals = synthesizeEquals(record)
            record.addMethod(equals)
        }
        // ... hashCode, toString
    }
}
```

### 4.3 SealedExhaustivenessPass

**检查sealed类的穷尽性**:

```kotlin
class SealedExhaustivenessPass : ComponentPass() {

    override fun accept(component: Component) {
        component.walk { switch ->
            if (switch is SwitchExpression) {
                checkExhaustiveness(switch)
            }
        }
    }

    private fun checkExhaustiveness(switch: SwitchExpression) {
        val selectorType = switch.selector?.type as? SealedType ?: return

        val coveredTypes = switch.cases
            .mapNotNull { case ->
                when (val label = case.label) {
                    is TypeTestPattern -> label.testedType
                    else -> null
                }
            }
            .toSet()

        if (!selectorType.checkExhaustiveness(coveredTypes)) {
            // Report: Switch不完整
            addProblem(switch, "Non-exhaustive switch on sealed type")
        }
    }
}
```

---

## 五、测试验证计划

### 5.1 单元测试

每个新功能必须有对应的测试：

```kotlin
// RecordTest.kt
@Test
fun testRecordComponents() {
    val code = """
        record Point(int x, int y) {}
    """
    val record = parseAndAnalyze(code)

    assertEquals(2, record.components.size)
    assertNotNull(record.findComponent("x"))
    assertEquals("int", record.findComponent("x").type.name)
}

// PatternMatchingTest.kt
@Test
fun testInstanceOfPattern() {
    val code = """
        if (obj instanceof String s) {
            return s.length();
        }
    """
    val pattern = findPattern(code)

    assertNotNull(pattern.variable)
    assertEquals("String", pattern.variable.type.name)
}
```

### 5.2 集成测试

使用真实的Java 17代码：

```java
// 测试所有特性的组合
sealed interface Shape permits Circle, Rectangle {}
record Circle(double radius) implements Shape {}
record Rectangle(double width, double height) implements Shape {}

public class ShapeProcessor {
    public double area(Shape shape) {
        return switch (shape) {
            case Circle(var r) -> Math.PI * r * r;
            case Rectangle(var w, var h) -> w * h;
            // 无需default，sealed保证穷尽
        };
    }
}
```

### 5.3 性能测试

确保新特性不影响性能：
- 基准测试：分析1000个Java文件
- 内存使用：监控新节点的内存开销
- 分析时间：确保不超过基线10%

---

## 六、部署计划

### 阶段1：Alpha（第4周）
- D1, D2修复
- var推断
- 基础Record支持

### 阶段2：Beta（第8周）
- 完整Record实现
- 基础Pattern Matching
- Switch表达式

### 阶段3：RC（第12周）
- Sealed Classes
- 完整Pattern Matching
- 所有测试通过

### 阶段4：Release（第14周）
- 性能优化
- 文档完成
- 正式发布

---

## 七、风险缓解

### 技术风险
1. **节点系统扩展影响现有代码**
   - 缓解：保持向后兼容，新节点继承现有基类

2. **性能下降**
   - 缓解：增量实现，每步测量性能

### 进度风险
1. **Eclipse JDT集成延迟**
   - 缓解：核心改进独立于前端，可并行进行

2. **测试发现新问题**
   - 缓解：预留20%缓冲时间

---

## 八、成功标准

1. **功能完整性**: Java 11-17特性支持度达到85%
2. **性能保持**: 分析时间增加不超过10%
3. **向后兼容**: 现有Java 8-10代码分析不受影响
4. **测试覆盖**: 新增代码测试覆盖率>80%
5. **文档完整**: 所有新特性有使用文档

---

## 结论

本实施方案通过分阶段、增量式的方法，在3-4个月内将CPG对Java 17的支持从28%提升到85%以上。优先修复高ROI缺陷（D1、var推断），然后逐步实现核心新特性。每个阶段都有明确的交付物和验证标准，确保质量和进度可控。