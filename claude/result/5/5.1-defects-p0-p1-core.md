# CPG 缺陷修复人力资源分析报告

## 第一部分 a: P0-P1 核心缺陷技能分析 (D1-D4)

**文档**: 5.1-defects-p0-p1-core.md
**范围**: P0-P1 优先级的 4 个核心缺陷 (D1-D4)
**目标**: 详细分析每个缺陷的技能需求、资历级别、知识领域和协作模式

---

## 📋 本文档概览

本文档分析 **4 个最关键的缺陷** (P0-P1),这些缺陷直接阻塞 Task 3 的场景或过程间分析能力:

| 缺陷 ID | 名称 | 优先级 | 阻塞影响 | 复杂度 | 预计工作量 |
|--------|------|--------|---------|--------|-----------|
| **D1** | Static Final DFG 缺失 (静态常量 DFG 缺失) | P0 | 100% 场景 | 中高 (集成) | 40-80 小时 |
| **D2** | String.equals() 缺失 (字符串比较缺失) | P0 | 100% 场景 | 低 | 20-40 小时 |
| **D3** | Interprocedural DFG 缺失 (过程间 DFG 缺失) | P1 | 50% 场景 | 极高 (算法) | 80-150 小时 |
| **D4** | Call Graph 缺失 (调用图缺失) | P1 | 50% 场景 | 极高 (基础设施) | 120-240 小时 |

**总计**: 260-510 人时 (1.5-3 人月)

---

## 分析框架

每个缺陷的分析包含 **5 个维度**:

1. **缺陷概述**: 简要描述 (面向非技术读者)
2. **所需技能**: 必备技能 / 重要技能 / 加分技能
3. **所需资历级别**: 研究与设计 / 实现 / 测试 / 集成各阶段所需资历
4. **知识领域分类**: 主要领域, 算法复杂度, 集成复杂度
5. **缺陷依赖关系和可并行性**: 依赖关系, 可并行性, 协作需求

---

## D1: Static Final Field DFG Missing

### D1.1 缺陷概述

**缺陷 ID**: D1
**名称**: Static Final Field DFG 缺失 (静态常量字段数据流缺失)
**优先级**: P0
**类别**: A (阻塞 Task 3 场景)

**描述** (面向非技术读者):

Java 程序中,开发者通常将配置常量定义为 `static final` 字段 (如 `public static final String API_URL = "https://..."`),这是行业最佳实践。约 **70% 的 Java 常量**使用这种模式。

当前 CPG 无法追踪这些常量的数据流,导致无法判断哪些代码路径会被执行,哪些不会。结果是分析工具报告大量误报 (报告代码可达,实际上不可达),**精度降低 80%+**。

**影响**:
- 阻塞 Task 3 的所有 4 个场景 (100% 场景失败)
- 真实项目分析精度降至近零
- 误报率: 83% (6 个类报告可达,实际只有 1 个)

**根本原因**:
这是一个 **Frontend-Core 集成缺陷**: 两边的责任边界不清晰,导致功能缺失。
- Frontend (Handler) 认为 DFG 边是 Core Pass 的责任
- Core (DFGPass) 认为 static final 是 Java 特定的,不应由 Core 处理
- **结果**: 两边都不做,导致 DFG 缺失

---

### D1.2 所需技能

#### 必备技能

**1. Java static final 语义深度理解**
- **技能水平**: Expert (专家级)
- **详细说明**:
  - 理解 `static final` 的编译期/运行期语义
  - 理解常量折叠 (constant folding) vs 运行期求值
  - 理解 `static final` 与 `enum` 的区别
  - 理解不同类型的 static final (primitive, String, Object reference)
- **关键性说明**: 没有这个理解,无法判断哪些值可以在编译期确定,哪些需要运行期求值
- **验证方式**: 候选人应能回答 "为什么 `static final int X = 1 + 2` 可以内联,但 `static final int Y = new Random().nextInt()` 不行?"

**2. CPG DFG (Data Flow Graph) 机制深度理解**
- **技能水平**: Senior (高级)
- **详细说明**:
  - 理解 DFG 边的创建时机 (哪个 Pass 负责,何时执行)
  - 理解 DFG 边的语义 (prevDFG, nextDFG,代表什么关系)
  - 理解 ValueEvaluator 如何沿 DFG 回溯求值
  - 理解 intra-procedural DFG vs interprocedural DFG 的区别
- **关键性说明**: D1 的核心问题是 DFG 边缺失,必须理解 DFG 机制才能修复
- **验证方式**: 候选人应能解释 "从 field access 到 field initializer,需要几条 DFG 边?中间经过哪些节点?"

**3. CPG Handler Pattern 和 Frontend-Core 架构理解**
- **技能水平**: Mid-to-Senior (中高级)
- **详细说明**:
  - 理解 FieldDeclarationHandler 的职责边界 (创建节点 vs 创建边)
  - 理解 Handler 与 Pass 的分工 (语言特定 vs 语言无关)
  - 理解如何在 Handler 中创建 DFG 边 (或是否应该在 Pass 中创建)
  - 理解 CPG 的多语言抽象设计 (为何 Core 不处理 Java 特定逻辑)
- **关键性说明**: D1 是 Frontend-Core 集成缺陷,需要理解责任边界,才能决定在哪里修复
- **验证方式**: 候选人应能回答 "如果在 Handler 中创建 DFG 边,会不会污染其他语言的 Frontend?"

#### 重要技能

**1. Kotlin 编程能力**
- **技能水平**: Mid (中级)
- **详细说明**: CPG 用 Kotlin 实现,需要能阅读和编写 Kotlin 代码,理解 Kotlin 的 null-safety, extension functions, data classes 等特性
- **预计学习时间**: 1-2 weeks (if experienced Java developer)
- **验证方式**: 候选人应能编写简单的 Kotlin Pass 或 Handler

**2. CPG Pass Infrastructure 理解**
- **技能水平**: Mid (中级)
- **详细说明**: 理解 Pass 的执行顺序,依赖关系,如何注册 Pass,Pass 之间如何共享信息 (如通过 ScopeManager, TypeManager)
- **重要性说明**: 可能需要创建新的 Language-Specific Pass (如 JavaDFGPass)
- **验证方式**: 候选人应能解释 "DFGPass 在哪个阶段执行?在 EvaluationOrderGraphPass 之前还是之后?"

**3. 测试驱动开发 (TDD) 经验**
- **技能水平**: Mid (中级)
- **详细说明**: 能够编写单元测试和集成测试,验证 DFG 边正确性,使用 Spock 或 JUnit 编写测试
- **重要性说明**: D1 修复需要覆盖所有 Java 常量模式 (primitive, String, enum, final vs non-final, 等等),测试覆盖率要求高
- **验证方式**: 候选人应能设计测试用例 "如何测试 static final String vs static final Object 的 DFG 边创建?"

#### 加分技能

**1. 编译器理论背景**
- **详细说明**: 学过编译原理课程,理解 SSA, Phi nodes, constant propagation, reaching definitions 等概念
- **帮助说明**: 更容易理解 DFG 的设计意图和理论基础,能够参考学术文献

**2. 熟悉其他静态分析框架 (Soot, WALA, SpotBugs)**
- **详细说明**: 知道其他工具如何处理 static final 常量,了解 Soot 的 Jimple IR, WALA 的 SSA IR
- **帮助说明**: 可以参考成熟工具的设计,避免重复踩坑

**3. CPG 上游贡献经验**
- **详细说明**: 曾向 Fraunhofer-AISEC/cpg 提交过 PR,熟悉上游的 code review 流程和代码风格
- **帮助说明**: 熟悉上游代码风格和 review 流程,修复更容易被上游接受 (如果需要贡献回上游)

---

### D1.3 所需资历级别

| 缺陷修复阶段 | 最低资历级别 | 推荐资历级别 | 理由 |
|-------------|------------|------------|------|
| **Research & Design** | Mid-level (2-4 years) | Senior (5+ years) | 需要架构思维,理解 Frontend-Core 分离的设计权衡,决定在哪里创建 DFG 边 (Handler vs Pass),需要考虑多语言抽象的影响 |
| **Implementation** | Junior (0-2 years) | Mid-level (2-4 years) | 代码实现本身不复杂 (创建 DFG 边类似现有局部变量 DFG 逻辑),但需要理解上下文,处理边界情况 (如 static final Object vs primitive) |
| **Testing & Validation** | Mid-level (2-4 years) | Senior (5+ years) | 需要设计测试覆盖所有 Java 常量模式 (primitive, String, enum, array, final vs non-final, compile-time constant vs runtime),需要测试设计经验 |
| **Integration** | Senior (5+ years) | Expert (10+ years) | 跨 Frontend-Core 集成,需要全局理解,确保不破坏其他语言的 DFG,需要协调多个模块 (Handler, DFGPass, ValueEvaluator),经验要求高 |

**整体**: 此缺陷修复应由 **Senior (5+ years)** 主导,协助人员可以是 **Mid-level (2-4 years)**。

**理由说明**:
- **High Integration Complexity**: D1 是跨 Frontend-Core 的集成缺陷,需要同时理解两边的架构,理解为何现有设计会产生这个 gap
- **Multiple Stakeholders**: 涉及 Handler (Frontend), DFGPass (Core), ValueEvaluator (Core),需要协调多个模块,确保修改不破坏现有功能
- **High Risk**: 如果实现不当,可能破坏现有功能 (如其他语言的 DFG,或局部变量 DFG),需要 Senior 级别的谨慎和经验
- **Architectural Decision**: 需要决定 "在哪里创建 DFG 边" (3 种可能: Handler 内, Language-Specific Pass, Core Pass 扩展),这是架构决策,需要 Senior 思维

---

### D1.4 知识领域分类

**主要领域**: **Integration** (Frontend + Core 集成)

**Why Integration (not Frontend or Core)**:
- D1 不是单纯的 Frontend 问题 (Handler 可以创建 DFG 边,但需要 Core 支持)
- D1 不是单纯的 Core 问题 (DFGPass 可以处理 static final,但需要 Frontend 提供类型信息)
- D1 是两者之间的**责任边界不清晰**导致的功能缺失

**次要领域**:
- **Frontend Domain**: 需要修改或扩展 FieldDeclarationHandler,可能需要新增 Handler 回调
- **Core Domain**: 需要理解 DFGPass 和 ValueEvaluator,确保 DFG 边可以被正确使用

**算法复杂度**: **Low**
- 算法本身不复杂: 只需在 FieldDeclaration.initializer 和 FieldAccessExpression 之间创建 DFG 边
- 类似现有的局部变量 DFG 逻辑 (VariableDeclaration → Reference)
- 无需新的算法或数据结构

**集成复杂度**: **High**
- 需要决定责任边界: Handler 创建 vs Pass 创建 vs 新增 Language-Specific Pass
- 需要考虑多语言抽象: 不能污染其他语言的 DFG (如 C++ 的 static const, Python 的 class variable 可能有不同语义)
- 需要处理边界情况: static final 的不同类型 (primitive, String, Object),compile-time constant vs runtime value
- 需要协调多个模块: Handler, DFGPass, ValueEvaluator

**整体复杂度**: **Medium-to-High** (算法简单但集成复杂)

---

### D1.5 缺陷依赖关系和可并行性

**可并行性**: **Yes** (可并行)
- D1 可以独立于其他缺陷进行分析和修复
- 与 D2 (String.equals) 无技术依赖 (虽然 Scenario 1 需要 D1+D2 都修复才能完全工作,但两者可以并行开发)
- 与 D3-D4 (过程间分析) 无技术依赖

**依赖关系**: **None**
- D1 不依赖其他缺陷的修复
- 可以作为第一批修复目标 ("Quick Win" 的一部分)

**Depended by** (被依赖关系):
- **D2 (String.equals)**: Scenario 1 需要 D1+D2 都修复才能完全工作 (但可并行开发)
- **D3 (Interprocedural DFG)**: 过程间 DFG 也需要处理 static final 的跨方法传播 (D1 修复后,D3 可以基于此扩展)
- **D6 (Enum Constants)**: Enum 内部使用 static final,D1 修复后 D6 也受益

**Collaboration Needs** (协作需求):
- **Primary Role**: Integration Engineer (主导设计和集成,决定在哪里创建 DFG 边)
- **Supporting Role**: Frontend Specialist (实现 Handler 部分的修改,如扩展 FieldDeclarationHandler)
- **Review Role**: Core Specialist (review DFG Pass 部分的修改,确保不破坏现有逻辑)
- **Testing Role**: Testing Specialist (设计测试用例,覆盖所有 Java 常量模式)

**协作模式**: **Integration-Led Collaboration** (集成驱动协作)
- Integration Engineer 设计 Frontend-Core 接口 (如 Handler 调用 Pass, 或 Pass 读取 Handler 创建的节点)
- Frontend Specialist 实现 Handler 修改 (如在 FieldDeclarationHandler 中创建 DFG 边)
- Core Specialist review DFG Pass 修改 (确保 ValueEvaluator 可以正确沿 DFG 回溯)
- **Communication**: Daily sync (15 分钟) 确保两边对齐,Weekly architecture review 确保设计合理

---

## D2: String.equals() Not in ValueEvaluator

### D2.1 缺陷概述

**Defect ID**: D2
**Name**: String.equals() Not in ValueEvaluator (字符串比较求值缺失)
**Priority**: P0
**Category**: A (Blocking Task 3 Scenarios)

**描述** (面向非技术读者):

Java 程序中,字符串比较的标准方法是 `str1.equals(str2)` (而非 `str1 == str2`,后者比较引用而非内容)。这种比较在条件判断中极其常见,占所有条件判断的 **60%+**。

当前 CPG 无法计算 `String.equals()` 的结果 (即使两边的字符串都已知),导致无法判断条件的真假,进而无法剪枝不可达代码。

**影响**:
- 阻塞 Task 3 的所有 4 个场景 (100% 场景失败)
- 与 D1 结合,是最致命的组合 (真实项目常见模式: `if (var.equals(CONSTANT_FIELD))`)
- 误报率: 83% (与 D1 相同,因为两者共同作用导致所有条件都无法求值)

**根本原因**:
这是一个 **多语言抽象代价缺陷**: ValueEvaluator 设计为语言无关,不内置任何语言特定的方法求值逻辑。
- 其他语言有不同的字符串比较方法 (Python: `==`, C++: `.compare()`, JavaScript: `===`)
- 如果在 Core ValueEvaluator 内置 Java 的 `String.equals()`,会污染多语言抽象
- **结果**: 为了保持抽象纯粹,牺牲了 60% 场景的可用性

---

### D2.2 所需技能

#### 必备技能

**1. Java String 语义深度理解**
- **技能水平**: Mid-to-Senior (中高级)
- **详细说明**:
  - 理解 `String.equals()` vs `==` 的区别 (内容比较 vs 引用比较)
  - 理解 String interning (字符串驻留,如 `"a" == "a"` 可能为 true)
  - 理解 String 不可变性 (immutability,`String.equals()` 无副作用)
  - 理解 null 处理 (`"a".equals(null)` → false, `null.equals("a")` → NullPointerException)
- **关键性说明**: 需要正确实现 `equals()` 的语义,避免 edge cases 导致错误结果
- **验证方式**: 候选人应能回答 "为什么 `\"a\".equals(\"a\")` 和 `\"a\" == \"a\"` 可能有不同结果?什么情况下相同?"

**2. CPG ValueEvaluator 机制理解**
- **技能水平**: Mid (中级)
- **详细说明**:
  - 理解 ValueEvaluator.evaluate() 的工作流程 (遍历 AST,递归求值子表达式)
  - 理解如何扩展 ValueEvaluator 支持新的表达式类型 (如 MemberCallExpression)
  - 理解 cannotEvaluate 的返回条件 (何时返回 null,何时返回 Value)
  - 理解 Value 类型系统 (IntValue, StringValue, BooleanValue, etc.)
- **关键性说明**: D2 的核心是扩展 ValueEvaluator 支持方法调用求值,必须理解现有机制
- **验证方式**: 候选人应能解释 "ValueEvaluator 如何求值 `1 + 2`?为什么 `method()` 返回 null?"

**3. Java 方法调用语义**
- **技能水平**: Mid (中级)
- **详细说明**:
  - 理解方法调用的 receiver (接收者,如 `str.equals()` 中的 `str`) 和 arguments (参数,如 `equals("a")` 中的 `"a"`)
  - 理解静态方法 vs 实例方法 (static method vs instance method)
  - 理解方法调用的副作用 (side effects,纯函数 vs 有副作用的方法)
  - 理解哪些方法可以安全地内置求值 (如 `String.equals()`, `Integer.valueOf()`),哪些不行 (如 `System.currentTimeMillis()`, `Math.random()`)
- **关键性说明**: 需要判断哪些方法可以安全地内置求值,避免内置有副作用或不确定的方法
- **验证方式**: 候选人应能回答 "为什么可以内置 `String.length()`,但不能内置 `String.replace()`?"

#### 重要技能

**1. Kotlin 编程能力**
- **技能水平**: Mid (中级)
- **详细说明**: 实现 ValueEvaluator 扩展,编写 when 表达式处理 MemberCallExpression

**2. 测试设计经验**
- **技能水平**: Mid (中级)
- **详细说明**: 覆盖所有 String.equals() 的 edge cases:
  - Basic: `"a".equals("a")` → true, `"a".equals("b")` → false
  - Null: `"a".equals(null)` → false, `null.equals("a")` → NullPointerException (需要处理)
  - Case sensitivity: `"A".equals("a")` → false (vs `"A".equalsIgnoreCase("a")` → true)
  - Empty string: `"".equals("")` → true
  - Unicode: `"你好".equals("你好")` → true
- **重要性说明**: 需要确保实现的 `equals()` 求值与 Java 标准库行为完全一致

**3. Java 标准库熟悉度**
- **Skill Level**: Junior-to-Mid
- **详细说明**: 知道哪些标准库方法可以内置求值 (白名单):
  - String: `equals()`, `isEmpty()`, `length()`, `compareTo()`, `startsWith()`, `endsWith()`
  - Integer: `valueOf()`, `parseInt()`
  - Boolean: `valueOf()`, `parseBoolean()`
  - Collections: `isEmpty()`, `size()` (如果已知 collection 是空的)
- **重要性说明**: D2 修复后,可以扩展支持更多方法,提升精度

#### 加分技能

**1. 编译器优化背景**
- **详细说明**: 理解 constant folding, pure function inlining, intrinsics (编译器内置函数)
- **帮助说明**: 知道哪些方法可以安全地优化 (如 JVM 的 intrinsics for `String.equals()`)

**2. 其他静态分析工具经验**
- **详细说明**: 知道 Soot/WALA 如何处理方法调用求值,了解它们的白名单 (哪些方法可内置)
- **帮助说明**: 参考成熟工具的白名单,避免遗漏常用方法

---

### D2.3 所需资历级别

| 缺陷修复阶段 | 最低资历级别 | 推荐资历级别 | 理由 |
|-------------|------------|------------|------|
| **Research & Design** | Junior (0-2 years) | Mid-level (2-4 years) | 设计相对简单 (扩展 ValueEvaluator 支持 MemberCallExpression),但需要考虑 edge cases (null, exception) 和白名单范围 (哪些方法可内置) |
| **Implementation** | Junior (0-2 years) | Mid-level (2-4 years) | 代码实现简单 (when 分支 + String 比较),但需要处理所有 edge cases,确保与 Java 语义一致 |
| **Testing & Validation** | Mid-level (2-4 years) | Mid-level (2-4 years) | 需要设计全面的测试覆盖,包括 corner cases (null, empty, unicode),确保无遗漏 |
| **Integration** | Mid-level (2-4 years) | Senior (5+ years) | 需要确保不破坏现有的 ValueEvaluator 逻辑 (如算术运算符求值),需要考虑性能 (如白名单查找) |

**整体**: 此缺陷修复应由 **Mid-level (2-4 years)** 主导,Junior 可协助实现。

**理由说明**:
- **Low Algorithm Complexity**: 实现 `String.equals()` 求值逻辑很简单 (字符串比较)
- **Low Integration Complexity**: 只需扩展 ValueEvaluator,不跨 Frontend-Core,不涉及多个模块协调
- **但 Edge Cases 多**: 需要仔细测试,防止 NullPointerException, 空字符串, Unicode 等问题
- **Mid-level 足够**: 有 2-4 年经验的工程师应该能够独立完成,无需 Senior 级别

---

### D2.4 知识领域分类

**主要领域**: **Core Domain** (ValueEvaluator 位于 CPG Core)

**Why Core (not Frontend)**:
- D2 的修复完全在 Core 的 ValueEvaluator 模块
- 不涉及 Frontend (Handler 不需要修改)
- 不涉及 Frontend-Core 集成

**次要领域**:
- **Java Language Semantics**: 需要理解 String.equals() 语义,确保实现正确

**算法复杂度**: **Low**
- 实现非常简单: 比较两个字符串是否相等 (Kotlin: `str1 == str2` 即可,因为 Kotlin 的 `==` 等价于 Java 的 `equals()`)
- 无需复杂的数据结构或算法

**集成复杂度**: **Low**
- 只需扩展 ValueEvaluator 的 when 表达式,增加 MemberCallExpression 的处理分支
- 不涉及 Frontend,不涉及多个模块协调

**整体复杂度**: **Low** (最简单的 P0 缺陷,适合作为 "Quick Win" 的一部分)

---

### D2.5 缺陷依赖关系和可并行性

**可并行性**: **Yes** (可并行)
- D2 可以独立于其他缺陷修复
- 与 D1 可以并行开发 (虽然 Scenario 1 需要两者都修复,但修复过程可并行)
- 与 D3-D4 无关联

**依赖关系**: **None**

**Depended by** (被依赖关系):
- **D1 (Static Final DFG)**: Scenario 1 需要 D1+D2 都修复才能完全工作
- **D5 (Integer Evaluation)**: 类似的 "扩展 ValueEvaluator" 问题,D2 可作为参考模板

**Collaboration Needs** (协作需求):
- **Primary Role**: Core Specialist (主导实现,扩展 ValueEvaluator)
- **Review Role**: Frontend Specialist (review Java 语义正确性,确保 `equals()` 行为与 Java 标准库一致)
- **Testing Role**: Testing Specialist (设计测试用例,覆盖所有 edge cases)

**协作模式**: **Specialist-Led Collaboration** (专家驱动协作)
- Core Specialist 独立实现 (1-2 天完成)
- Bi-weekly progress update (无需 daily sync,因为复杂度低)
- Testing Specialist 提供测试用例清单 (edge cases list)
- Frontend Specialist review 一次 (确保 Java 语义正确)

---

## D3: Interprocedural DFG Missing

### D3.1 缺陷概述

**Defect ID**: D3
**Name**: Interprocedural DFG Missing (过程间数据流缺失)
**Priority**: P1
**Category**: A (Blocking Task 3 Scenarios 2 & 3)

**描述** (面向非技术读者):

真实 Java 项目中,**30-40% 的代码**涉及多层方法调用 (A 调用 B, B 调用 C)。常量值常常在方法之间传递,例如:
- 配置常量从 Service 层传递到 DAO 层
- Feature flags 从 Controller 传递到业务逻辑
- API keys 从配置类传递到 HTTP 客户端

当前 CPG 只能追踪单个方法内的数据流 (intra-procedural),无法跨越方法边界 (interprocedural)。这导致 ValueEvaluator 无法追踪过程间的常量传播。

**影响**:
- 阻塞 Task 3 的 Scenario 2 和 Scenario 3 (50% 场景失败)
- 真实项目中,30-40% 的常量传播失效
- 是过程间分析的核心基础设施

**根本原因**:
这是一个 **架构设计缺陷**: DFG 设计时只考虑了单方法分析 (intra-procedural),缺少过程间支持 (interprocedural)。
- DFG 只在方法内创建边,不创建跨方法的边 (caller → callee, return → call site)
- 缺少过程间 DFG 算法 (如 summary-based, context-sensitive)

---

### D3.2 所需技能

#### 必备技能

**1. 过程间数据流分析算法 (Interprocedural Dataflow Analysis)**
- **技能水平**: Expert (专家级)
- **详细说明**:
  - 理解 Summary-based interprocedural DFG (为每个方法计算 summary,然后在 call site 应用 summary)
  - 理解 Context-sensitive vs Context-insensitive 分析 (区分不同调用上下文)
  - 理解如何处理递归调用 (直接递归, 间接递归,固定点迭代)
  - 理解如何处理函数指针/虚函数调用 (Java 的 interface 调用, 多态)
  - 理解 k-CFA (k-call-site sensitivity), object-sensitivity 等精度控制方法
- **关键性说明**: D3 需要实现过程间 DFG,算法复杂度高,需要深厚的理论背景
- **验证方式**: 候选人应能解释 "Summary-based 和 Context-sensitive 的区别是什么?各有什么优缺点?"

**2. Call Graph 深度理解**
- **技能水平**: Senior (高级)
- **详细说明**:
  - 理解 Call Graph 的构建和使用 (CHA, RTA, VTA)
  - 理解如何沿 Call Graph 传播 DFG 信息 (topological order, worklist algorithm)
  - 理解 Call Graph 精度对 DFG 精度的影响 (不精确的 Call Graph 导致不精确的 DFG)
  - 理解如何处理 Call Graph 的环 (递归调用)
- **关键性说明**: 过程间 DFG **强依赖** Call Graph (D4),必须理解 Call Graph 才能设计 D3
- **验证方式**: 候选人应能回答 "如果 Call Graph 遗漏了一个调用边,过程间 DFG 会有什么影响?"

**3. CPG Pass Infrastructure 深度理解**
- **技能水平**: Senior (高级)
- **详细说明**:
  - 理解 Pass 的执行顺序和依赖关系 (D3 必须在 D4 之后执行)
  - 理解如何创建新的 Core Pass (InterproceduralDFGPass)
  - 理解 Pass 之间如何共享信息 (如 Call Graph 从 CallGraphPass 传递到 InterproceduralDFGPass)
  - 理解如何设计 Pass 的配置选项 (如 context-sensitivity level, max recursion depth)
- **关键性说明**: D3 需要创建新的 InterproceduralDFGPass,需要深度理解 Pass 架构
- **验证方式**: 候选人应能设计 "InterproceduralDFGPass 需要哪些配置选项?如何从 CallGraphPass 读取 Call Graph?"

#### 重要技能

**1. 图算法 (Graph Algorithms)**
- **技能水平**: Mid-to-Senior (中高级)
- **详细说明**: 图遍历 (BFS, DFS), 拓扑排序 (用于 Call Graph 的反向遍历), 强连通分量 (用于检测递归)
- **重要性说明**: 过程间 DFG 需要遍历 Call Graph,需要图算法知识

**2. Java 方法调用语义**
- **技能水平**: Mid (中级)
- **详细说明**: 参数传递 (pass-by-value,Java 的对象引用传递), 返回值语义 (return statement), 异常传播 (try-catch 对 DFG 的影响)
- **重要性说明**: 需要正确建模参数传递和返回值的 DFG 边

**3. 性能优化经验**
- **技能水平**: Mid (中级)
- **详细说明**: 过程间分析可能很慢 (大型项目有上万个方法),需要优化:
  - Caching (缓存 method summary,避免重复计算)
  - Incremental analysis (只重新分析修改过的方法)
  - Demand-driven analysis (只分析查询需要的方法,而非全程序分析)
- **重要性说明**: D3 的性能直接影响工具的可用性,需要优化经验

#### 加分技能

**1. 研究论文阅读能力**
- **详细说明**: 能阅读 PLDI/POPL/OOPSLA 论文,了解 state-of-the-art 过程间分析算法:
  - IFDS/IDE (Interprocedural Finite Distributive Subset)
  - Pointer analysis (Andersen, Steensgaard)
  - Tabulation-based algorithms
- **帮助说明**: 过程间 DFG 有大量研究文献可参考,阅读能力帮助理解最新算法

**2. 熟悉 Soot/WALA 的过程间分析**
- **详细说明**: 知道 Soot 的 IFDS/IDE 框架, WALA 的 Tabulation solver
- **帮助说明**: 可参考成熟实现,避免从零开始设计

---

### D3.3 所需资历级别

| 缺陷修复阶段 | 最低资历级别 | 推荐资历级别 | 理由 |
|-------------|------------|------------|------|
| **Research & Design** | Senior (5+ years) | Expert (10+ years) | 过程间分析算法复杂,需要深厚理论背景,需要设计 summary-based 算法,需要考虑 context-sensitivity, recursion, performance |
| **Implementation** | Mid-level (2-4 years) | Senior (5+ years) | 实现复杂,容易出现性能问题 (如递归导致无限循环) 和 edge cases (如异常传播, finally block),需要 Senior 经验 |
| **Testing & Validation** | Senior (5+ years) | Senior (5+ years) | 测试需要覆盖递归, 虚函数, 异常传播等复杂场景,需要设计大型测试用例 (multi-method call chains),需要 Senior 测试设计经验 |
| **Integration** | Senior (5+ years) | Expert (10+ years) | 需要与 D4 (Call Graph) 紧密集成,需要确保 Pass 执行顺序正确,需要协调 DFGPass 和 InterproceduralDFGPass 的关系,经验要求极高 |

**整体**: 此缺陷修复应由 **Expert (10+ years)** 主导,Senior 协助实现。

**理由说明**:
- **Very High Algorithm Complexity**: 过程间 DFG 是静态分析的核心难题,算法复杂度高,需要 PhD 级别的理论背景或 10+ 年实战经验
- **Very High Risk**: 实现不当会导致:
  - 严重的性能问题 (如全程序分析需要数小时)
  - 严重的精度问题 (如 context-insensitive 导致大量误报)
  - 递归调用导致无限循环 (栈溢出)
- **Requires Deep Expertise**: 需要理论背景 (算法) 和工程经验 (性能优化) 兼备,Mid-level 无法胜任
- **Critical Infrastructure**: 过程间 DFG 是很多下游分析的基础 (如 taint analysis, slicing),质量要求极高

---

### D3.4 知识领域分类

**主要领域**: **Graph Algorithms** (过程间 DFG 算法)

**Why Graph Algorithms**:
- D3 的核心是设计和实现过程间数据流分析算法,属于图算法领域
- 需要遍历 Call Graph,传播 DFG 信息,涉及图的拓扑排序,环检测,固定点迭代等图算法

**次要领域**:
- **Core Pass Infrastructure**: 需要创建新的 InterproceduralDFGPass,理解 Pass 架构
- **Performance Engineering**: 需要优化性能 (caching, incremental, demand-driven)

**算法复杂度**: **Very High**
- 过程间 DFG 是 NP-hard 问题的近似算法 (如 k-CFA 的复杂度是 O(n^k))
- Summary-based 算法需要固定点迭代,可能需要多轮遍历
- Context-sensitive 分析的复杂度随上下文深度指数增长

**集成复杂度**: **High**
- 强依赖 D4 (Call Graph),D3 必须等 D4 完成后才能开始
- 需要协调 DFGPass (intra-procedural) 和 InterproceduralDFGPass 的关系
- 需要设计 Pass 之间的信息传递机制 (如 Call Graph, Method Summary)

**整体复杂度**: **Very High** (最复杂的 P1 缺陷之一,与 D4 并列)

---

### D3.5 缺陷依赖关系和可并行性

**可并行性**: **No** (不可并行)
- D3 **强依赖** D4 (Call Graph)
- 必须等 D4 完成后才能开始 D3 (因为过程间 DFG 需要 Call Graph 指导如何传播信息)
- D3 和 D4 是**顺序依赖关系**,无法并行

**依赖关系**:
- **D4 (Call Graph)**: **强依赖**,必须先完成 D4

**Depended by** (被依赖关系):
- Scenario 2 和 Scenario 3 需要 D3 才能工作
- 未来的 taint analysis, slicing 等高级分析也依赖 D3

**Collaboration Needs** (协作需求):
- **Primary Role**: Core Specialist (主导实现,设计过程间 DFG 算法)
- **Supporting Role**: Integration Engineer (协调 D3 与 D4 的接口,设计 Pass 之间的信息传递)
- **Review Role**: Performance Engineer (review 性能,确保不会太慢)

**协作模式**: **Sequential Dependency Collaboration** (顺序依赖协作)
- **Step 1**: 等 D4 完成 (Call Graph 可用)
- **Step 2**: Handoff meeting (2 小时,D4 开发者向 D3 开发者讲解 Call Graph API)
- **Step 3**: D3 启动 (Core Specialist 主导,Integration Engineer 协调)
- **Communication**: Weekly sync 与 D4 开发者对齐 (确保 Call Graph 满足 D3 需求)

---

## D4: Call Graph Infrastructure Missing

### D4.1 缺陷概述

**Defect ID**: D4
**Name**: Call Graph Infrastructure Missing (调用图基础设施缺失)
**Priority**: P1
**Category**: A (Blocking Task 3 Scenarios 2 & 3)

**描述** (面向非技术读者):

Call Graph (调用图) 是静态分析的基础设施,记录程序中"哪个方法调用哪个方法"。它是过程间分析的前提:只有知道调用关系,才能追踪数据在方法之间的流动。

类比: Call Graph 就像公司的组织架构图,记录"谁向谁汇报"。没有组织架构图,就无法知道信息如何在部门之间流动。

当前 CPG 缺少 Call Graph 基础设施,导致所有过程间分析都无法进行。

**影响**:
- 阻塞 Task 3 的 Scenario 2 和 Scenario 3 (50% 场景失败)
- D4 是 D3 的前提,是关键路径上的瓶颈
- 预计工作量: 120-240 person-hours (3-6 person-weeks),是最耗时的 P1 缺陷

**根本原因**:
这是一个 **基础设施缺失**: CPG 设计时未考虑过程间分析,缺少 Call Graph 这一基础设施。

---

### D4.2 所需技能

#### 必备技能

**1. Call Graph 构建算法 (Call Graph Construction Algorithms)**
- **技能水平**: Expert (专家级)
- **详细说明**:
  - 理解 CHA (Class Hierarchy Analysis): 最快但最不精确,基于类型层次结构
  - 理解 RTA (Rapid Type Analysis): 中等速度和精度,基于实际创建的类型
  - 理解 VTA (Variable Type Analysis): 更精确,基于变量类型
  - 理解 k-CFA, object-sensitivity 等高精度算法: 最精确但最慢
  - 理解如何处理虚函数调用 (virtual dispatch): Java 的接口调用,方法重写
  - 理解如何处理反射调用 (reflection): `Method.invoke()`, `Class.forName()`
- **关键性说明**: D4 需要实现 Call Graph 构建算法,算法选择直接影响精度和性能
- **验证方式**: 候选人应能解释 "CHA, RTA, VTA 的精度和性能如何排序?各适用什么场景?"

**2. Java 类型系统和方法解析 (Java Type System and Method Resolution)**
- **技能水平**: Senior (高级)
- **详细说明**:
  - 理解方法重载 (overloading): 同名方法,不同参数 (编译期决定调用哪个)
  - 理解方法重写 (overriding): 子类重写父类方法 (运行期决定调用哪个,动态绑定)
  - 理解接口调用的解析: `interface I { void m(); }`, `I obj = new Impl(); obj.m();` 调用哪个?
  - 理解泛型方法的解析: `<T> void m(T x)` 的调用解析
  - 理解 Java 的方法查找规则: 优先查找当前类,然后父类,然后接口
- **关键性说明**: Java 的方法解析非常复杂,Call Graph 依赖准确的类型信息和方法解析
- **验证方式**: 候选人应能回答 "给定 `A extends B`, `a.m()` 如何解析?如果 B 也定义了 m() 呢?"

**3. CPG Core Pass 设计 (CPG Core Pass Design)**
- **技能水平**: Senior (高级)
- **详细说明**:
  - 理解如何创建新的 Core Pass (CallGraphPass,需要继承哪个基类,实现哪些方法)
  - 理解如何在 CPG 中表示 Call Graph:
    - 新的边类型 (CALLS edge)? 还是独立的数据结构 (Map<MethodDeclaration, Set<MethodDeclaration>>)?
  - 理解 Pass 之间如何共享 Call Graph 信息 (如通过 ScopeManager, 或自定义的 CallGraphManager)
  - 理解 Pass 的执行顺序 (CallGraphPass 应该在哪个阶段执行?在 TypeResolver 之后)
- **关键性说明**: D4 需要新的 Pass 和数据结构,需要深度理解 CPG 架构
- **验证方式**: 候选人应能设计 "如何在 CPG 中表示 Call Graph?用边还是独立数据结构?各有什么优缺点?"

#### 重要技能

**1. 图算法 (Graph Algorithms)**
- **技能水平**: Mid-to-Senior (中高级)
- **详细说明**: 图构建 (incremental graph construction), 图遍历 (traversal), 环检测 (cycle detection,用于递归调用)
- **重要性说明**: Call Graph 本身是一个有向图,需要图算法知识

**2. Java 反射 (Reflection) 处理**
- **技能水平**: Mid (中级)
- **详细说明**: 如何处理反射调用:
  - `Method.invoke(obj, args)`: 需要分析 `Method` 对象从哪里来
  - `Class.forName("A").newInstance()`: 需要分析字符串常量
  - `Constructor.newInstance()`: 需要处理构造函数调用
- **重要性说明**: 真实项目中,5-10% 的调用是反射调用,影响 Call Graph 完整性

**3. 性能优化 (Performance Optimization)**
- **技能水平**: Mid (中级)
- **详细说明**: Call Graph 构建可能很慢 (大型项目有上万个方法,CHA 需要遍历所有子类):
  - Caching: 缓存方法解析结果
  - Incremental: 只重新计算修改过的部分
  - Parallel: 并行构建 Call Graph (需要小心竞态条件)
- **重要性说明**: D4 的性能直接影响所有下游分析 (D3, D7, D19)

#### 加分技能

**1. 熟悉 Soot/WALA 的 Call Graph**
- **详细说明**: 知道 Soot 的 Spark (pointer analysis + call graph), WALA 的 0-CFA
- **帮助说明**: 可参考成熟实现,了解常见 pitfalls (如递归调用的处理,反射调用的近似)

**2. 研究论文阅读能力**
- **详细说明**: 能阅读 Call Graph 相关论文 (如 k-CFA 的原始论文, object-sensitivity 论文)
- **帮助说明**: 了解 state-of-the-art 算法,为未来精度提升 (D19) 做准备

---

### D4.3 所需资历级别

| 缺陷修复阶段 | 最低资历级别 | 推荐资历级别 | 理由 |
|-------------|------------|------------|------|
| **Research & Design** | Senior (5+ years) | Expert (10+ years) | Call Graph 算法复杂 (CHA vs RTA vs VTA),需要深厚理论背景,需要设计 Call Graph 的表示方式 (边 vs 数据结构),需要考虑精度和性能的权衡 |
| **Implementation** | Mid-level (2-4 years) | Senior (5+ years) | 实现复杂,需要处理 Java 的各种调用模式 (重载,重写,接口,泛型,反射),容易出现 edge cases (如 lambda 调用,匿名类调用),需要 Senior 经验 |
| **Testing & Validation** | Senior (5+ years) | Senior (5+ years) | 测试需要覆盖重载, 接口, 泛型, 反射, 递归等场景,需要设计大型测试用例 (multi-level inheritance, complex call chains),需要验证 Call Graph 的完整性和精度,需要 Senior 测试设计经验 |
| **Integration** | Senior (5+ years) | Expert (10+ years) | Call Graph 是基础设施,错误会级联到所有下游分析 (D3, D7, D19),需要确保 API 设计合理 (易于其他 Pass 使用),需要考虑性能 (不能太慢,否则所有下游分析都慢),经验要求极高 |

**整体**: 此缺陷修复应由 **Expert (10+ years)** 主导,Senior 协助实现。

**理由说明**:
- **Critical Infrastructure**: Call Graph 是基础设施,质量要求极高,错误会影响所有下游分析
- **Very High Complexity**: Java 的方法解析非常复杂 (重载,重写,接口,泛型,反射),算法选择需要深厚理论背景
- **Very High Risk**: Call Graph 错误会级联到所有过程间分析 (D3, taint analysis, slicing),影响范围广
- **Long-term Impact**: Call Graph 的 API 设计会影响未来的所有扩展 (D19, D26),需要 Expert 级别的前瞻性

---

### D4.4 知识领域分类

**主要领域**: **Graph Algorithms** (Call Graph 构建)

**Why Graph Algorithms**:
- D4 的核心是构建 Call Graph (有向图),属于图算法领域
- 需要图遍历 (traversal), 环检测 (cycle detection), 增量图构建 (incremental graph construction)

**次要领域**:
- **Java Language Semantics**: 方法解析 (overloading, overriding, interface resolution)
- **Core Pass Infrastructure**: 新 Pass 创建 (CallGraphPass)

**算法复杂度**: **High**
- CHA 算法相对简单 (O(n×m), n=方法数, m=子类数),但 RTA/VTA 更复杂
- 需要处理递归调用 (环检测), 反射调用 (字符串分析)
- 高精度算法 (k-CFA) 的复杂度是指数级 (O(n^k))

**集成复杂度**: **High**
- Call Graph 需要集成到 CPG 的多个 Pass (D3 需要读取, D7 需要更新, D19 需要精化)
- 需要设计清晰的 API (如 `getCalleesOf(method)`, `getCallersOf(method)`)
- 需要考虑性能 (Call Graph 构建不能太慢,否则所有下游分析都慢)

**整体复杂度**: **Very High** (与 D3 并列最复杂的 P1 缺陷)

---

### D4.5 缺陷依赖关系和可并行性

**可并行性**: **Partial** (部分并行)
- D4 的基础实现 (CHA) 可以独立进行,不依赖其他缺陷
- 但 D4 的精度提升 (RTA) 可能 **弱依赖** D7 (Type System): 更准确的类型信息可以提升 Call Graph 精度
- D4 和 D1-D2 可以完全并行 (无关联)
- D4 和 D10 (Parallel) 可以完全并行

**依赖关系**:
- **D7 (Type System)**: **弱依赖** (D7 提升 D4 精度,但非必需,D4 可以先用 CHA 实现,后续集成 D7 提升精度)

**Depended by** (被依赖关系):
- **D3 (Interprocedural DFG)**: **强依赖** (D3 必须等 D4 完成)
- **D19 (Call Graph Precision)**: 扩展 D4,提升精度

**Collaboration Needs** (协作需求):
- **Primary Role**: Core Specialist (主导实现,设计 Call Graph 算法和 API)
- **Supporting Role**: Integration Engineer (设计 Call Graph API,确保易于其他 Pass 使用)
- **Supporting Role**: Frontend Specialist (提供类型信息,帮助方法解析)
- **Review Role**: Performance Engineer (review 性能,确保不会太慢)

**协作模式**: **Specialist-Led Collaboration** (专家驱动协作)
- Core Specialist 主导 (设计 + 实现)
- Weekly sync 与 Integration Engineer 对齐 API 设计
- Bi-weekly sync 与 Frontend Specialist 对齐类型信息需求
- Monthly performance review 与 Performance Engineer (确保性能可接受)

---

## 第一部分 a 总结

### 关键发现 (Key Findings)

**1. 复杂度分层清晰**:
- **Low Complexity**: D2 (String.equals) - Mid-level 足够
- **Medium Complexity**: D1 (Static Final DFG) - Senior 推荐
- **Very High Complexity**: D3, D4 - Expert 必需

**2. D1 + D2 是 "Quick Win"**:
- 修复工作量: 60-120 hours (1.5-3 person-weeks)
- 可解锁: 50% Task 3 场景 (Scenario 1, 4)
- ROI 最高,应优先修复

**3. D4 → D3 是关键路径**:
- D4 是瓶颈 (120-240 hours, 3-6 person-weeks)
- D3 必须等 D4 完成 (强依赖)
- 两者合计: 200-390 hours (5-10 person-weeks)
- 可解锁: 100% Task 3 场景 (Scenario 2, 3)

**4. 技能需求多样化**:
- Java 语义: D1, D2 (需要 Java 专家)
- 图算法: D3, D4 (需要算法专家)
- 集成: D1 (需要 Frontend-Core 都理解的 Integration Engineer)

**5. 协作模式差异**:
- D1: 集成驱动 (Integration-Led, Daily sync)
- D2: 专家驱动 (Specialist-Led, Bi-weekly)
- D3: 顺序依赖 (Sequential, Handoff meeting)
- D4: 专家驱动 (Specialist-Led, Weekly sync)

---

### Next Steps (下一步)

继续阅读:
- **[5.2-defects-p1-rest.md](./5.2-defects-p1-rest.md)**: P1 剩余缺陷 (D5, D7, D10, D12, D17) + 选定 P2 缺陷
- **[5.3-roles-and-teams.md](./5.3-roles-and-teams.md)**: 6 个角色定义, 3 种团队规模, 4 种协作模式
- **[5.4-appendices.md](./5.4-appendices.md)**: 技能到缺陷矩阵, 角色对比表, 术语表

---

**Part 1a 完成**: D1-D4 详细分析完毕,共 4 个 P0-P1 核心缺陷,总工作量 260-510 person-hours。

---
