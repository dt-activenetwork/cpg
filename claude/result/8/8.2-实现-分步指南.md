# 8.2 CPG å®¹å™¨åŒ–æ¶æ„ - å®ç°åˆ†æ­¥æŒ‡å—

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0
**åˆ›å»ºæ—¥æœŸ**: 2025-11-12
**ç›®æ ‡è¯»è€…**: å¼€å‘è€…ã€å®æ–½è€…
**æ–‡æ¡£ç›®æ ‡**: æŒ‰æ­¥éª¤å®ç°åºåˆ—åŒ–ã€å®¹å™¨åŒ–ã€æµ‹è¯•ï¼Œç¡®ä¿å¯é‡å¤æ‰§è¡Œ

---

## ç›®å½•

1. [å‰ç½®å‡†å¤‡](#1-å‰ç½®å‡†å¤‡)
2. [Phase 1: åºåˆ—åŒ–/ååºåˆ—åŒ–å®ç°](#2-phase-1-åºåˆ—åŒ–ååºåˆ—åŒ–å®ç°)
3. [Phase 2: å®¹å™¨åŒ–æ‰“åŒ…](#3-phase-2-å®¹å™¨åŒ–æ‰“åŒ…)
4. [æµ‹è¯•è®¡åˆ’](#4-æµ‹è¯•è®¡åˆ’)
5. [éªŒæ”¶æ ‡å‡†](#5-éªŒæ”¶æ ‡å‡†)
6. [æ•…éšœæ’æŸ¥](#6-æ•…éšœæ’æŸ¥)
7. [æ€»ç»“](#7-æ€»ç»“)

---

## 1. å‰ç½®å‡†å¤‡

### 1.1 å¼€å‘ç¯å¢ƒè¦æ±‚

| ç»„ä»¶ | ç‰ˆæœ¬è¦æ±‚ | éªŒè¯å‘½ä»¤ |
|------|---------|---------|
| JDK | 17+ | `java -version` |
| Kotlin | 1.9+ | `kotlinc -version` |
| Gradle | 8.0+ | `gradle -version` |
| Docker | 24.0+ | `docker --version` |
| Docker Compose | 2.20+ | `docker-compose --version` |

---

### 1.2 ä»£ç ä»“åº“å‡†å¤‡

**1. åˆ›å»ºæ–°æ¨¡å—**ï¼š
```bash
cd cpg-core
mkdir -p src/main/kotlin/de/fraunhofer/aisec/cpg/persistence
mkdir -p src/test/kotlin/de/fraunhofer/aisec/cpg/persistence
```

**2. æ·»åŠ  Gradle ä¾èµ–**ï¼ˆ`build.gradle.kts`ï¼‰ï¼š
```kotlin
dependencies {
    // CPG æ ¸å¿ƒä¾èµ–ï¼ˆå·²æœ‰ï¼‰
    implementation(project(":cpg-core"))

    // Kotlin Scripting Engineï¼ˆæŸ¥è¯¢å®¹å™¨éœ€è¦ï¼‰
    implementation("org.jetbrains.kotlin:kotlin-scripting-jvm:1.9.22")
    implementation("org.jetbrains.kotlin:kotlin-scripting-jvm-host:1.9.22")
    implementation("org.jetbrains.kotlin:kotlin-scripting-common:1.9.22")

    // åºåˆ—åŒ–åº“ï¼ˆå¾… Phase 1 Step 1 é€‰å®šåæ·»åŠ ï¼‰
    // implementation("com.esotericsoftware:kryo:5.6.0")  // ç¤ºä¾‹ï¼šKryo
    // æˆ– implementation("de.ruedigermoeller:fst:3.0.4-jdk17")  // ç¤ºä¾‹ï¼šFST

    // æµ‹è¯•ä¾èµ–
    testImplementation("org.junit.jupiter:junit-jupiter:5.10.0")
    testImplementation("io.kotest:kotest-assertions-core:5.8.0")
}
```

---

### 1.3 æµ‹è¯•æ•°æ®å‡†å¤‡

**å‡†å¤‡ä¸åŒè§„æ¨¡çš„æµ‹è¯•ä»£ç ä»“åº“**ï¼š

| è§„æ¨¡ | LOC | é¢„æœŸèŠ‚ç‚¹æ•° | ç”¨é€” |
|------|-----|----------|------|
| å°å‹ | <10K | <10K | å¿«é€Ÿè¿­ä»£æµ‹è¯• |
| ä¸­å‹ | 30-50K | 30-50K | æ€§èƒ½åŸºå‡†æµ‹è¯• |
| å¤§å‹ | 100K+ | 100K+ | å‹åŠ›æµ‹è¯• |

**ç¤ºä¾‹æµ‹è¯•ä»“åº“**ï¼š
```bash
# å°å‹ï¼šCPG è‡ªèº«æµ‹è¯•ä»£ç 
TEST_REPO_SMALL=cpg-core/src/test/resources/eog

# ä¸­å‹ï¼šå¼€æº Java é¡¹ç›®
TEST_REPO_MEDIUM=https://github.com/openjdk/jdk (subset)

# å¤§å‹ï¼šSpring Framework
TEST_REPO_LARGE=https://github.com/spring-projects/spring-framework
```

---

## 2. Phase 1: åºåˆ—åŒ–/ååºåˆ—åŒ–å®ç°

**æ€»ä½“æ—¶é—´çº¿**ï¼š2-3 å‘¨
**ä¸»è¦ä»»åŠ¡**ï¼šå®ç°å›¾çš„åºåˆ—åŒ–ã€ååºåˆ—åŒ–ã€å¾€è¿”æµ‹è¯•ã€æ€§èƒ½ä¼˜åŒ–

---

### 2.1 Step 1: åºåˆ—åŒ–åº“è°ƒç ”ä¸é€‰å‹ï¼ˆ2-3 å¤©ï¼‰

#### 2.1.1 å€™é€‰åº“åˆ—è¡¨

| åº“ | å®˜æ–¹æ–‡æ¡£ | Gradle ä¾èµ– |
|---|---------|-----------|
| **Kryo** | https://github.com/EsotericSoftware/kryo | `com.esotericsoftware:kryo:5.6.0` |
| **FST** | https://github.com/RuedigerMoeller/fast-serialization | `de.ruedigermoeller:fst:3.0.4-jdk17` |
| **Protocol Buffers** | https://protobuf.dev/ | `com.google.protobuf:protobuf-java:3.25.1` |

---

#### 2.1.2 åŸºå‡†æµ‹è¯•ä»£ç 

**åˆ›å»ºæµ‹è¯•ç±»**ï¼ˆ`SerializationBenchmark.kt`ï¼‰ï¼š

```kotlin
package de.fraunhofer.aisec.cpg.persistence

import de.fraunhofer.aisec.cpg.TranslationManager
import de.fraunhofer.aisec.cpg.TranslationResult
import java.io.File
import kotlin.system.measureTimeMillis

class SerializationBenchmark {

    data class BenchmarkResult(
        val library: String,
        val serializeTimeMs: Long,
        val deserializeTimeMs: Long,
        val fileSizeBytes: Long,
        val nodeCount: Int,
        val edgeCount: Int
    )

    fun benchmarkLibrary(
        library: String,
        result: TranslationResult,
        outputFile: File
    ): BenchmarkResult {
        // 1. åºåˆ—åŒ–
        val serializeTime = measureTimeMillis {
            when (library) {
                "Kryo" -> serializeWithKryo(result, outputFile)
                "FST" -> serializeWithFST(result, outputFile)
                "ProtoBuf" -> serializeWithProtoBuf(result, outputFile)
                else -> throw IllegalArgumentException("Unknown library: $library")
            }
        }

        // 2. ååºåˆ—åŒ–
        var deserializedResult: TranslationResult? = null
        val deserializeTime = measureTimeMillis {
            deserializedResult = when (library) {
                "Kryo" -> deserializeWithKryo(outputFile)
                "FST" -> deserializeWithFST(outputFile)
                "ProtoBuf" -> deserializeWithProtoBuf(outputFile)
                else -> throw IllegalArgumentException("Unknown library: $library")
            }
        }

        // 3. éªŒè¯å¾€è¿”ä¸€è‡´æ€§
        validateRoundtrip(result, deserializedResult!!)

        return BenchmarkResult(
            library = library,
            serializeTimeMs = serializeTime,
            deserializeTimeMs = deserializeTime,
            fileSizeBytes = outputFile.length(),
            nodeCount = result.components.flatMap { it.allChildren<Node>() }.size,
            edgeCount = result.components.flatMap { it.allChildren<Node>() }
                .flatMap { it.nextEOG + it.prevEOG + it.nextDFG + it.prevDFG }.size
        )
    }

    // Kryo åºåˆ—åŒ–å®ç°
    private fun serializeWithKryo(result: TranslationResult, outputFile: File) {
        val kryo = Kryo().apply {
            // é…ç½®å¾ªç¯å¼•ç”¨å¤„ç†
            references = true
            // æ³¨å†Œ CPG ç±»ï¼ˆå¯é€‰ï¼Œå¯æé«˜æ€§èƒ½ï¼‰
            register(TranslationResult::class.java)
            register(de.fraunhofer.aisec.cpg.graph.Node::class.java)
            // ... æ³¨å†Œå…¶ä»–å¸¸ç”¨ç±»
        }

        Output(FileOutputStream(outputFile)).use { output ->
            kryo.writeObject(output, result)
        }
    }

    private fun deserializeWithKryo(inputFile: File): TranslationResult {
        val kryo = Kryo().apply {
            references = true
            register(TranslationResult::class.java)
            register(de.fraunhofer.aisec.cpg.graph.Node::class.java)
        }

        Input(FileInputStream(inputFile)).use { input ->
            return kryo.readObject(input, TranslationResult::class.java)
        }
    }

    // FST åºåˆ—åŒ–å®ç°
    private fun serializeWithFST(result: TranslationResult, outputFile: File) {
        val conf = FSTConfiguration.createDefaultConfiguration()
        val bytes = conf.asByteArray(result)
        outputFile.writeBytes(bytes)
    }

    private fun deserializeWithFST(inputFile: File): TranslationResult {
        val conf = FSTConfiguration.createDefaultConfiguration()
        val bytes = inputFile.readBytes()
        return conf.asObject(bytes) as TranslationResult
    }

    // Protocol Buffers åºåˆ—åŒ–å®ç°ï¼ˆéœ€è¦é¢„å®šä¹‰ .proto schemaï¼‰
    private fun serializeWithProtoBuf(result: TranslationResult, outputFile: File) {
        // 1. è½¬æ¢ TranslationResult â†’ Proto å¯¹è±¡
        val proto = result.toProto()  // éœ€è¦æ‰‹åŠ¨å®ç°è½¬æ¢é€»è¾‘

        // 2. åºåˆ—åŒ–
        outputFile.outputStream().use {
            proto.writeTo(it)
        }
    }

    private fun deserializeWithProtoBuf(inputFile: File): TranslationResult {
        // 1. ååºåˆ—åŒ– Proto å¯¹è±¡
        val proto = inputFile.inputStream().use {
            GraphProto.parseFrom(it)
        }

        // 2. è½¬æ¢ Proto å¯¹è±¡ â†’ TranslationResult
        return proto.toTranslationResult()  // éœ€è¦æ‰‹åŠ¨å®ç°è½¬æ¢é€»è¾‘
    }

    // å¾€è¿”ä¸€è‡´æ€§éªŒè¯
    private fun validateRoundtrip(original: TranslationResult, deserialized: TranslationResult) {
        val originalNodes = original.components.flatMap { it.allChildren<Node>() }
        val deserializedNodes = deserialized.components.flatMap { it.allChildren<Node>() }

        // éªŒè¯èŠ‚ç‚¹æ•°ä¸€è‡´
        require(originalNodes.size == deserializedNodes.size) {
            "Node count mismatch: ${originalNodes.size} vs ${deserializedNodes.size}"
        }

        // éªŒè¯è¾¹æ•°ä¸€è‡´ï¼ˆEOG, DFGï¼‰
        val originalEOGCount = originalNodes.flatMap { it.nextEOG }.size
        val deserializedEOGCount = deserializedNodes.flatMap { it.nextEOG }.size
        require(originalEOGCount == deserializedEOGCount) {
            "EOG count mismatch: $originalEOGCount vs $deserializedEOGCount"
        }

        // éªŒè¯å…³é”®å±æ€§ï¼ˆå¦‚ unreachableï¼‰
        val originalUnreachable = originalNodes.filterIsInstance<EvaluationOrder>()
            .count { it.unreachable == true }
        val deserializedUnreachable = deserializedNodes.filterIsInstance<EvaluationOrder>()
            .count { it.unreachable == true }
        require(originalUnreachable == deserializedUnreachable) {
            "Unreachable count mismatch: $originalUnreachable vs $deserializedUnreachable"
        }

        println("âœ… Roundtrip validation passed")
    }
}
```

---

#### 2.1.3 è¿è¡ŒåŸºå‡†æµ‹è¯•

**æµ‹è¯•è„šæœ¬**ï¼ˆ`run-benchmark.sh`ï¼‰ï¼š

```bash
#!/bin/bash

# å‡†å¤‡æµ‹è¯•æ•°æ®
echo "Building test graphs..."
./gradlew :cpg-core:test -Dtest.single=TranslationManagerTest

# è¿è¡ŒåŸºå‡†æµ‹è¯•
echo "Running serialization benchmarks..."
./gradlew :cpg-core:test -Dtest.single=SerializationBenchmark

# ç”ŸæˆæŠ¥å‘Š
echo "Generating benchmark report..."
cat benchmark-results.csv | column -t -s ','
```

**é¢„æœŸè¾“å‡º**ï¼ˆ`benchmark-results.csv`ï¼‰ï¼š

| Library | Serialize (ms) | Deserialize (ms) | File Size (MB) | Nodes | Edges |
|---------|---------------|-----------------|----------------|-------|-------|
| Kryo    | 1200          | 2400            | 45.2           | 50000 | 180000 |
| FST     | 1400          | 2800            | 52.1           | 50000 | 180000 |
| ProtoBuf| 2200          | 3500            | 68.5           | 50000 | 180000 |

---

#### 2.1.4 å†³ç­–æ ‡å‡†

**è¯„åˆ†è¡¨**ï¼ˆ1-5 åˆ†ï¼Œ5 åˆ†æœ€å¥½ï¼‰ï¼š

| ç»´åº¦ | æƒé‡ | Kryo | FST | ProtoBuf |
|------|------|------|-----|---------|
| **ç´§å‡‘æ€§**ï¼ˆæ–‡ä»¶å¤§å°ï¼‰| 30% | 5 | 4 | 3 |
| **åºåˆ—åŒ–é€Ÿåº¦** | 25% | 5 | 4 | 3 |
| **ååºåˆ—åŒ–é€Ÿåº¦** | 25% | 5 | 4 | 3 |
| **å¾ªç¯å¼•ç”¨å¤„ç†** | 10% | 5 (è‡ªåŠ¨) | 5 (è‡ªåŠ¨) | 2 (éœ€æ‰‹åŠ¨) |
| **é›†æˆéš¾åº¦** | 10% | 5 (ç®€å•) | 5 (ç®€å•) | 2 (éœ€ schema) |
| **åŠ æƒæ€»åˆ†** | 100% | **5.0** | **4.2** | **2.8** |

**æ¨èå†³ç­–**ï¼š
- âœ… **Kryo**ï¼šå¦‚æœåŸºå‡†æµ‹è¯•ç¡®è®¤æ€§èƒ½æœ€ä¼˜ï¼ˆæ¨èï¼‰
- âœ… **FST**ï¼šå¦‚æœ Kryo æœ‰å…¼å®¹æ€§é—®é¢˜ï¼ˆå¤‡é€‰ï¼‰
- âŒ **ProtoBuf**ï¼šéœ€è¦æ‰‹åŠ¨ç¼–å†™ schemaï¼Œä¸æ¨èï¼ˆé™¤ééœ€è¦è·¨è¯­è¨€ï¼‰

---

#### 2.1.5 Step 1 äº¤ä»˜ç‰©

- âœ… åŸºå‡†æµ‹è¯•ä»£ç ï¼ˆ`SerializationBenchmark.kt`ï¼‰
- âœ… åŸºå‡†æµ‹è¯•æŠ¥å‘Šï¼ˆ`benchmark-results.csv`ï¼‰
- âœ… é€‰å‹å†³ç­–æ–‡æ¡£ï¼ˆ`serialization-library-decision.md`ï¼‰

**å†³ç­–æ–‡æ¡£æ¨¡æ¿**ï¼š
```markdown
# åºåˆ—åŒ–åº“é€‰å‹å†³ç­–

## åŸºå‡†æµ‹è¯•ç»“æœ

ï¼ˆç²˜è´´ benchmark-results.csvï¼‰

## å†³ç­–

**é€‰æ‹©**: Kryo

**ç†ç”±**:
1. æ–‡ä»¶å¤§å°æœ€å°ï¼ˆ45.2 MB vs 52.1 MB vs 68.5 MBï¼‰
2. åºåˆ—åŒ–é€Ÿåº¦æœ€å¿«ï¼ˆ1200 ms vs 1400 ms vs 2200 msï¼‰
3. ååºåˆ—åŒ–é€Ÿåº¦æœ€å¿«ï¼ˆ2400 ms vs 2800 ms vs 3500 msï¼‰
4. è‡ªåŠ¨å¤„ç†å¾ªç¯å¼•ç”¨ï¼Œæ— éœ€æ‰‹åŠ¨å¤„ç†
5. é›†æˆç®€å•ï¼Œæ— éœ€ç¼–å†™ schema

**é£é™©**:
- Kryo ä¸æ˜¯è·¨è¯­è¨€çš„ï¼ˆä½†å½“å‰ä¸éœ€è¦ï¼‰
- éœ€è¦æ³¨å†Œå¸¸ç”¨ç±»ï¼ˆå¯é€šè¿‡é»˜è®¤ç­–ç•¥è§£å†³ï¼‰

**æ—¥æœŸ**: 2025-11-12
**è´Ÿè´£äºº**: [å¼€å‘è€…å§“å]
```

---

### 2.2 Step 2: æ ¸å¿ƒåºåˆ—åŒ–å®ç°ï¼ˆ1 å‘¨ï¼‰

#### 2.2.1 åˆ›å»ºåºåˆ—åŒ– API

**æ–‡ä»¶**ï¼š`cpg-core/src/main/kotlin/de/fraunhofer/aisec/cpg/persistence/Serialization.kt`

```kotlin
package de.fraunhofer.aisec.cpg.persistence

import de.fraunhofer.aisec.cpg.TranslationResult
import de.fraunhofer.aisec.cpg.TranslationConfiguration
import com.esotericsoftware.kryo.Kryo
import com.esotericsoftware.kryo.io.Output
import java.io.File
import java.io.FileOutputStream

/**
 * åºåˆ—åŒ– TranslationResult åˆ°æ–‡ä»¶
 *
 * @param path è¾“å‡ºæ–‡ä»¶è·¯å¾„ï¼ˆä¾‹å¦‚ï¼š/output/graph.dumpï¼‰
 * @throws SerializationException å¦‚æœåºåˆ—åŒ–å¤±è´¥
 */
fun TranslationResult.serialize(path: String) {
    try {
        val outputFile = File(path)
        outputFile.parentFile?.mkdirs()  // åˆ›å»ºçˆ¶ç›®å½•

        // 1. åºåˆ—åŒ–ä¸»å›¾
        serializeGraph(outputFile)

        // 2. åºåˆ—åŒ–é…ç½®å…ƒæ•°æ®
        serializeConfig(File("$path.config.json"))

        // 3. åºåˆ—åŒ–ç»Ÿè®¡ä¿¡æ¯
        serializeStats(File("$path.stats.json"))

        println("âœ… Serialization completed: $path")
        println("   - Graph: ${outputFile.length() / 1024 / 1024} MB")
        println("   - Config: ${File("$path.config.json").length()} bytes")
        println("   - Stats: ${File("$path.stats.json").length()} bytes")

    } catch (e: Exception) {
        throw SerializationException("Failed to serialize TranslationResult", e)
    }
}

/**
 * åºåˆ—åŒ–ä¸»å›¾æ•°æ®
 */
private fun TranslationResult.serializeGraph(outputFile: File) {
    val kryo = createKryoInstance()

    Output(FileOutputStream(outputFile), 8192 * 4).use { output ->
        kryo.writeObject(output, this)
    }
}

/**
 * åˆ›å»º Kryo å®ä¾‹ï¼ˆé…ç½®å¾ªç¯å¼•ç”¨å¤„ç†ï¼‰
 */
private fun createKryoInstance(): Kryo {
    return Kryo().apply {
        // å¯ç”¨å¾ªç¯å¼•ç”¨å¤„ç†
        references = true

        // æ³¨å†Œå¸¸ç”¨ CPG ç±»ï¼ˆæé«˜æ€§èƒ½ï¼‰
        register(TranslationResult::class.java)
        register(TranslationConfiguration::class.java)
        register(de.fraunhofer.aisec.cpg.graph.Node::class.java)
        register(de.fraunhofer.aisec.cpg.graph.statements.Statement::class.java)
        register(de.fraunhofer.aisec.cpg.graph.statements.IfStatement::class.java)
        register(de.fraunhofer.aisec.cpg.graph.edges.flows.EvaluationOrder::class.java)
        register(de.fraunhofer.aisec.cpg.graph.edges.flows.Dataflow::class.java)
        // ... æ³¨å†Œå…¶ä»–å¸¸ç”¨ç±»ï¼ˆå¯é€‰ï¼‰

        // è®¾ç½®ç±»è§£æç­–ç•¥ï¼ˆå…è®¸æœªæ³¨å†Œçš„ç±»ï¼‰
        isRegistrationRequired = false
    }
}

/**
 * åºåˆ—åŒ–é…ç½®å…ƒæ•°æ®
 */
private fun TranslationResult.serializeConfig(outputFile: File) {
    val config = mapOf(
        "version" to "cpg-${this::class.java.`package`.implementationVersion}",
        "registeredPasses" to this.config.registeredPasses.map { passes ->
            passes.map { it.simpleName }
        },
        "languages" to this.config.languages,
        "buildTimestamp" to java.time.Instant.now().toString(),
        "gitInfo" to mapOf(
            "repo" to (this.config.softwareComponents.firstOrNull()?.location ?: "unknown"),
            "ref" to "unknown",  // éœ€è¦ä»ç¯å¢ƒå˜é‡è¯»å–
            "commit" to "unknown"
        )
    )

    outputFile.writeText(
        com.google.gson.GsonBuilder()
            .setPrettyPrinting()
            .create()
            .toJson(config)
    )
}

/**
 * åºåˆ—åŒ–ç»Ÿè®¡ä¿¡æ¯
 */
private fun TranslationResult.serializeStats(outputFile: File) {
    val allNodes = this.components.flatMap { it.allChildren<de.fraunhofer.aisec.cpg.graph.Node>() }
    val allEOG = allNodes.flatMap { it.nextEOG }
    val allDFG = allNodes.flatMap { it.nextDFG }

    val stats = mapOf(
        "nodeCount" to allNodes.size,
        "edgeCount" to (allEOG.size + allDFG.size),
        "eogEdgeCount" to allEOG.size,
        "dfgEdgeCount" to allDFG.size,
        "buildDurationSeconds" to 0,  // TODO: ä»æ„å»ºæ—¶è®°å½•
        "linesOfCode" to 0,  // TODO: ç»Ÿè®¡ LOC
        "fileCount" to this.components.size
    )

    outputFile.writeText(
        com.google.gson.GsonBuilder()
            .setPrettyPrinting()
            .create()
            .toJson(stats)
    )
}

/**
 * åºåˆ—åŒ–å¼‚å¸¸
 */
class SerializationException(message: String, cause: Throwable? = null) : Exception(message, cause)
```

---

#### 2.2.2 å•å…ƒæµ‹è¯•

**æ–‡ä»¶**ï¼š`cpg-core/src/test/kotlin/de/fraunhofer/aisec/cpg/persistence/SerializationTest.kt`

```kotlin
package de.fraunhofer.aisec.cpg.persistence

import de.fraunhofer.aisec.cpg.TranslationManager
import de.fraunhofer.aisec.cpg.graph.statements.IfStatement
import de.fraunhofer.aisec.cpg.passes.*
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.io.TempDir
import java.io.File
import kotlin.test.assertTrue
import kotlin.test.assertEquals

class SerializationTest {

    @TempDir
    lateinit var tempDir: File

    @Test
    fun `test serialize small graph`() {
        // 1. æ„å»ºå°å‹å›¾
        val result = TranslationManager.builder()
            .config {
                softwareComponents {
                    component {
                        location(File("src/test/resources/eog"))
                    }
                }
                registerLanguage<de.fraunhofer.aisec.cpg.frontends.java.JavaLanguage>()
                registerPass<EvaluationOrderGraphPass>()
                registerPass<ControlFlowSensitiveDFGPass>()
            }
            .build()
            .analyze()

        // 2. åºåˆ—åŒ–
        val outputPath = File(tempDir, "graph.dump").absolutePath
        result.serialize(outputPath)

        // 3. éªŒè¯æ–‡ä»¶å­˜åœ¨
        assertTrue(File(outputPath).exists(), "graph.dump should exist")
        assertTrue(File("$outputPath.config.json").exists(), "config.json should exist")
        assertTrue(File("$outputPath.stats.json").exists(), "stats.json should exist")

        // 4. éªŒè¯æ–‡ä»¶å¤§å° >0
        assertTrue(File(outputPath).length() > 0, "graph.dump should not be empty")
    }

    @Test
    fun `test serialize handles circular references`() {
        // æ„å»ºåŒ…å«å¾ªç¯å¼•ç”¨çš„å›¾ï¼ˆé€’å½’å‡½æ•°è°ƒç”¨ï¼‰
        val result = TranslationManager.builder()
            .config {
                softwareComponents {
                    component {
                        location(File("src/test/resources/recursion"))  // åŒ…å«é€’å½’å‡½æ•°
                    }
                }
                registerLanguage<de.fraunhofer.aisec.cpg.frontends.java.JavaLanguage>()
                registerPass<EvaluationOrderGraphPass>()
            }
            .build()
            .analyze()

        // åºåˆ—åŒ–åº”è¯¥ä¸æŠ›å‡ºå¼‚å¸¸ï¼ˆKryo è‡ªåŠ¨å¤„ç†å¾ªç¯å¼•ç”¨ï¼‰
        val outputPath = File(tempDir, "graph-circular.dump").absolutePath
        result.serialize(outputPath)

        // éªŒè¯æˆåŠŸ
        assertTrue(File(outputPath).exists())
    }
}
```

---

#### 2.2.3 Step 2 äº¤ä»˜ç‰©

- âœ… åºåˆ—åŒ– API å®ç°ï¼ˆ`Serialization.kt`ï¼‰
- âœ… å•å…ƒæµ‹è¯•ï¼ˆ`SerializationTest.kt`ï¼‰
- âœ… æµ‹è¯•é€šè¿‡ï¼ˆ`./gradlew test`ï¼‰

---

### 2.3 Step 3: ååºåˆ—åŒ–å®ç°ï¼ˆ1 å‘¨ï¼‰

#### 2.3.1 åˆ›å»ºååºåˆ—åŒ– API

**æ–‡ä»¶**ï¼š`cpg-core/src/main/kotlin/de/fraunhofer/aisec/cpg/persistence/Deserialization.kt`

```kotlin
package de.fraunhofer.aisec.cpg.persistence

import de.fraunhofer.aisec.cpg.TranslationResult
import de.fraunhofer.aisec.cpg.TranslationConfiguration
import com.esotericsoftware.kryo.Kryo
import com.esotericsoftware.kryo.io.Input
import java.io.File
import java.io.FileInputStream

/**
 * ä»æ–‡ä»¶ååºåˆ—åŒ– TranslationResult
 *
 * @param path è¾“å…¥æ–‡ä»¶è·¯å¾„ï¼ˆä¾‹å¦‚ï¼š/output/graph.dumpï¼‰
 * @param validateConfig æ˜¯å¦éªŒè¯ Pass é…ç½®å®Œæ•´æ€§ï¼ˆé»˜è®¤ï¼štrueï¼‰
 * @return ååºåˆ—åŒ–çš„ TranslationResult
 * @throws DeserializationException å¦‚æœååºåˆ—åŒ–å¤±è´¥
 */
fun TranslationResult.Companion.deserialize(
    path: String,
    validateConfig: Boolean = true
): TranslationResult {
    try {
        val inputFile = File(path)
        require(inputFile.exists()) { "Graph file not found: $path" }

        // 1. ååºåˆ—åŒ–ä¸»å›¾
        val result = deserializeGraph(inputFile)

        // 2. åŠ è½½é…ç½®å…ƒæ•°æ®
        val config = deserializeConfig(File("$path.config.json"))

        // 3. éªŒè¯é…ç½®ï¼ˆå¦‚æœéœ€è¦ï¼‰
        if (validateConfig) {
            validateConfiguration(result, config)
        }

        println("âœ… Deserialization completed: $path")
        println("   - Nodes: ${result.components.flatMap { it.allChildren<de.fraunhofer.aisec.cpg.graph.Node>() }.size}")
        println("   - EOG Edges: ${result.components.flatMap { it.allChildren<de.fraunhofer.aisec.cpg.graph.Node>() }.flatMap { it.nextEOG }.size}")
        println("   - DFG Edges: ${result.components.flatMap { it.allChildren<de.fraunhofer.aisec.cpg.graph.Node>() }.flatMap { it.nextDFG }.size}")

        return result

    } catch (e: Exception) {
        throw DeserializationException("Failed to deserialize TranslationResult", e)
    }
}

/**
 * ååºåˆ—åŒ–ä¸»å›¾æ•°æ®
 */
private fun deserializeGraph(inputFile: File): TranslationResult {
    val kryo = createKryoInstance()

    Input(FileInputStream(inputFile), 8192 * 4).use { input ->
        return kryo.readObject(input, TranslationResult::class.java)
    }
}

/**
 * ååºåˆ—åŒ–é…ç½®å…ƒæ•°æ®
 */
private fun deserializeConfig(inputFile: File): Map<String, Any> {
    require(inputFile.exists()) { "Config file not found: ${inputFile.absolutePath}" }

    return com.google.gson.Gson().fromJson(
        inputFile.readText(),
        Map::class.java
    ) as Map<String, Any>
}

/**
 * éªŒè¯é…ç½®å®Œæ•´æ€§
 */
private fun validateConfiguration(result: TranslationResult, config: Map<String, Any>) {
    // éªŒè¯ CPG ç‰ˆæœ¬å…¼å®¹æ€§
    val version = config["version"] as? String
    println("   - CPG Version: $version")

    // éªŒè¯ Pass é…ç½®
    val registeredPasses = config["registeredPasses"] as? List<*>
    println("   - Registered Passes: ${registeredPasses?.flatten()?.joinToString(", ")}")

    // TODO: æ›´ä¸¥æ ¼çš„éªŒè¯ï¼ˆå¦‚æœéœ€è¦ï¼‰
}

/**
 * ååºåˆ—åŒ–å¼‚å¸¸
 */
class DeserializationException(message: String, cause: Throwable? = null) : Exception(message, cause)
```

---

#### 2.3.2 å¾€è¿”æµ‹è¯•ï¼ˆRoundtrip Testï¼‰

**æ–‡ä»¶**ï¼š`cpg-core/src/test/kotlin/de/fraunhofer/aisec/cpg/persistence/RoundtripTest.kt`

```kotlin
package de.fraunhofer.aisec.cpg.persistence

import de.fraunhofer.aisec.cpg.TranslationManager
import de.fraunhofer.aisec.cpg.graph.statements.IfStatement
import de.fraunhofer.aisec.cpg.graph.edges.flows.EvaluationOrder
import de.fraunhofer.aisec.cpg.passes.*
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.io.TempDir
import java.io.File
import kotlin.test.assertEquals

class RoundtripTest {

    @TempDir
    lateinit var tempDir: File

    @Test
    fun `test roundtrip with small graph`() {
        // 1. æ„å»ºåŸå§‹å›¾
        val original = TranslationManager.builder()
            .config {
                softwareComponents {
                    component {
                        location(File("src/test/resources/eog"))
                    }
                }
                registerLanguage<de.fraunhofer.aisec.cpg.frontends.java.JavaLanguage>()
                registerPass<EvaluationOrderGraphPass>()
                registerPass<ControlFlowSensitiveDFGPass>()
                registerPass<UnreachableEOGPass>()
            }
            .build()
            .analyze()

        // 2. åºåˆ—åŒ–
        val graphPath = File(tempDir, "graph.dump").absolutePath
        original.serialize(graphPath)

        // 3. ååºåˆ—åŒ–
        val deserialized = TranslationResult.deserialize(graphPath)

        // 4. éªŒè¯ä¸€è‡´æ€§
        assertGraphEquals(original, deserialized)
    }

    @Test
    fun `test roundtrip preserves unreachable property`() {
        // 1. æ„å»ºåŒ…å«ä¸å¯è¾¾ä»£ç çš„å›¾
        val original = TranslationManager.builder()
            .config {
                softwareComponents {
                    component {
                        location(File("src/test/resources/unreachable"))  // åŒ…å« if(true)
                    }
                }
                registerLanguage<de.fraunhofer.aisec.cpg.frontends.java.JavaLanguage>()
                registerPass<EvaluationOrderGraphPass>()
                registerPass<ControlFlowSensitiveDFGPass>()
                registerPass<UnreachableEOGPass>()
            }
            .build()
            .analyze()

        // 2. ç»Ÿè®¡åŸå§‹å›¾çš„ unreachable è¾¹
        val originalUnreachable = original.components
            .flatMap { it.allChildren<de.fraunhofer.aisec.cpg.graph.Node>() }
            .flatMap { it.nextEOGEdges }
            .filterIsInstance<EvaluationOrder>()
            .count { it.unreachable == true }

        // 3. åºåˆ—åŒ– + ååºåˆ—åŒ–
        val graphPath = File(tempDir, "graph-unreachable.dump").absolutePath
        original.serialize(graphPath)
        val deserialized = TranslationResult.deserialize(graphPath)

        // 4. ç»Ÿè®¡ååºåˆ—åŒ–å›¾çš„ unreachable è¾¹
        val deserializedUnreachable = deserialized.components
            .flatMap { it.allChildren<de.fraunhofer.aisec.cpg.graph.Node>() }
            .flatMap { it.nextEOGEdges }
            .filterIsInstance<EvaluationOrder>()
            .count { it.unreachable == true }

        // 5. éªŒè¯ä¸€è‡´æ€§
        assertEquals(originalUnreachable, deserializedUnreachable,
            "Unreachable edge count should be preserved")
    }

    /**
     * éªŒè¯ä¸¤ä¸ªå›¾ç»“æ„ä¸€è‡´
     */
    private fun assertGraphEquals(original: TranslationResult, deserialized: TranslationResult) {
        val originalNodes = original.components.flatMap { it.allChildren<de.fraunhofer.aisec.cpg.graph.Node>() }
        val deserializedNodes = deserialized.components.flatMap { it.allChildren<de.fraunhofer.aisec.cpg.graph.Node>() }

        // éªŒè¯èŠ‚ç‚¹æ•°
        assertEquals(originalNodes.size, deserializedNodes.size, "Node count should match")

        // éªŒè¯ EOG è¾¹æ•°
        val originalEOG = originalNodes.flatMap { it.nextEOG }.size
        val deserializedEOG = deserializedNodes.flatMap { it.nextEOG }.size
        assertEquals(originalEOG, deserializedEOG, "EOG edge count should match")

        // éªŒè¯ DFG è¾¹æ•°
        val originalDFG = originalNodes.flatMap { it.nextDFG }.size
        val deserializedDFG = deserializedNodes.flatMap { it.nextDFG }.size
        assertEquals(originalDFG, deserializedDFG, "DFG edge count should match")

        // éªŒè¯ç‰¹å®šèŠ‚ç‚¹ç±»å‹æ•°é‡ï¼ˆå¦‚ IfStatementï¼‰
        val originalIfCount = originalNodes.filterIsInstance<IfStatement>().size
        val deserializedIfCount = deserializedNodes.filterIsInstance<IfStatement>().size
        assertEquals(originalIfCount, deserializedIfCount, "IfStatement count should match")

        println("âœ… Roundtrip validation passed")
    }
}
```

---

#### 2.3.3 æ€§èƒ½æµ‹è¯•

**æ–‡ä»¶**ï¼š`cpg-core/src/test/kotlin/de/fraunhofer/aisec/cpg/persistence/PerformanceTest.kt`

```kotlin
package de.fraunhofer.aisec.cpg.persistence

import de.fraunhofer.aisec.cpg.TranslationManager
import de.fraunhofer.aisec.cpg.passes.*
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.io.TempDir
import java.io.File
import kotlin.system.measureTimeMillis

class PerformanceTest {

    @TempDir
    lateinit var tempDir: File

    @Test
    fun `test serialization performance on large graph`() {
        // 1. æ„å»ºå¤§å‹å›¾ï¼ˆ50K+ èŠ‚ç‚¹ï¼‰
        val result = TranslationManager.builder()
            .config {
                softwareComponents {
                    component {
                        location(File("src/test/resources/large-project"))  // å¤§å‹æµ‹è¯•é¡¹ç›®
                    }
                }
                registerLanguage<de.fraunhofer.aisec.cpg.frontends.java.JavaLanguage>()
                registerPass<EvaluationOrderGraphPass>()
                registerPass<ControlFlowSensitiveDFGPass>()
                registerPass<UnreachableEOGPass>()
            }
            .build()
            .analyze()

        val nodeCount = result.components.flatMap { it.allChildren<de.fraunhofer.aisec.cpg.graph.Node>() }.size
        println("Graph size: $nodeCount nodes")

        // 2. æµ‹è¯•åºåˆ—åŒ–æ€§èƒ½
        val graphPath = File(tempDir, "graph-large.dump").absolutePath
        val serializeTime = measureTimeMillis {
            result.serialize(graphPath)
        }
        println("Serialization time: $serializeTime ms")

        val fileSize = File(graphPath).length() / 1024 / 1024  // MB
        println("File size: $fileSize MB")

        // 3. æµ‹è¯•ååºåˆ—åŒ–æ€§èƒ½
        val deserializeTime = measureTimeMillis {
            TranslationResult.deserialize(graphPath)
        }
        println("Deserialization time: $deserializeTime ms")

        // 4. éªŒè¯æ€§èƒ½ç›®æ ‡
        require(serializeTime < 30_000) { "Serialization should complete in <30 seconds (was: $serializeTime ms)" }
        require(deserializeTime < 60_000) { "Deserialization should complete in <60 seconds (was: $deserializeTime ms)" }
        require(fileSize < 500) { "File size should be <500 MB (was: $fileSize MB)" }

        println("âœ… Performance test passed")
    }
}
```

---

#### 2.3.4 Step 3 äº¤ä»˜ç‰©

- âœ… ååºåˆ—åŒ– API å®ç°ï¼ˆ`Deserialization.kt`ï¼‰
- âœ… å¾€è¿”æµ‹è¯•ï¼ˆ`RoundtripTest.kt`ï¼‰
- âœ… æ€§èƒ½æµ‹è¯•ï¼ˆ`PerformanceTest.kt`ï¼‰
- âœ… æµ‹è¯•é€šè¿‡ï¼ˆ`./gradlew test`ï¼‰

---

### 2.4 Step 4: ä¼˜åŒ–ï¼ˆå¯é€‰ï¼Œ3-5 å¤©ï¼‰

#### 2.4.1 ä¼˜åŒ– 1: åˆ†å—å­˜å‚¨ï¼ˆå¦‚æœæ–‡ä»¶ >1GBï¼‰

**é—®é¢˜**ï¼šå•ä¸ªæ–‡ä»¶è¿‡å¤§ï¼ŒåŠ è½½æ…¢

**è§£å†³æ–¹æ¡ˆ**ï¼š
```kotlin
// åˆ†å—åºåˆ—åŒ–
fun TranslationResult.serializeChunked(outputDir: String, chunkSize: Int = 10_000) {
    val allNodes = this.components.flatMap { it.allChildren<Node>() }

    // æŒ‰ chunkSize åˆ†å—
    allNodes.chunked(chunkSize).forEachIndexed { index, chunk ->
        val chunkFile = File(outputDir, "nodes-chunk-$index.bin")
        serializeChunk(chunk, chunkFile)
    }

    // å†™å…¥ manifest
    val manifest = mapOf(
        "chunkCount" to allNodes.size / chunkSize + 1,
        "chunkSize" to chunkSize,
        "totalNodes" to allNodes.size
    )
    File(outputDir, "manifest.json").writeText(manifest.toJson())
}
```

---

#### 2.4.2 ä¼˜åŒ– 2: å‹ç¼©ï¼ˆå‡å°‘æ–‡ä»¶å¤§å°ï¼‰

**ä½¿ç”¨ Deflate å‹ç¼©**ï¼š
```kotlin
import java.util.zip.DeflaterOutputStream
import java.util.zip.InflaterInputStream

fun TranslationResult.serializeCompressed(outputFile: File) {
    val kryo = createKryoInstance()

    DeflaterOutputStream(FileOutputStream(outputFile)).use { deflater ->
        Output(deflater, 8192 * 4).use { output ->
            kryo.writeObject(output, this)
        }
    }
}

fun deserializeCompressed(inputFile: File): TranslationResult {
    val kryo = createKryoInstance()

    InflaterInputStream(FileInputStream(inputFile)).use { inflater ->
        Input(inflater, 8192 * 4).use { input ->
            return kryo.readObject(input, TranslationResult::class.java)
        }
    }
}
```

---

#### 2.4.3 ä¼˜åŒ– 3: å»¶è¿ŸåŠ è½½ï¼ˆå‡å°‘å†…å­˜å ç”¨ï¼‰

**åˆ›å»º LazyTranslationResult**ï¼š
```kotlin
class LazyTranslationResult(
    private val graphDir: File
) : TranslationResult {
    private val nodeCache = mutableMapOf<Long, Node>()
    private val manifest = loadManifest(graphDir)

    override fun getNode(id: Long): Node {
        return nodeCache.getOrPut(id) {
            // ä»ç£ç›˜åŠ è½½å•ä¸ªèŠ‚ç‚¹
            loadNodeFromChunk(id, manifest)
        }
    }

    private fun loadNodeFromChunk(id: Long, manifest: Map<String, Any>): Node {
        val chunkIndex = id / (manifest["chunkSize"] as Int)
        val chunkFile = File(graphDir, "nodes-chunk-$chunkIndex.bin")

        // åªåŠ è½½åŒ…å«è¯¥èŠ‚ç‚¹çš„åˆ†å—
        val chunk = deserializeChunk(chunkFile)
        return chunk.find { it.id == id } ?: error("Node not found: $id")
    }
}
```

---

## 3. Phase 2: å®¹å™¨åŒ–æ‰“åŒ…

**æ€»ä½“æ—¶é—´çº¿**ï¼š1 å‘¨
**ä¸»è¦ä»»åŠ¡**ï¼šæ„å»ºå®¹å™¨é•œåƒã€æŸ¥è¯¢å®¹å™¨é•œåƒã€Docker Compose ç¼–æ’

---

### 3.1 Step 1: æ„å»ºå®¹å™¨å®ç°ï¼ˆ2-3 å¤©ï¼‰

#### 3.1.1 Dockerfile

**æ–‡ä»¶**ï¼š`docker/build-container/Dockerfile`

```dockerfile
# åŸºç¡€é•œåƒï¼šGradle + JDK 17
FROM gradle:8.5-jdk17 AS builder

# è®¾ç½®å·¥ä½œç›®å½•
WORKDIR /cpg

# å¤åˆ¶é¡¹ç›®æ–‡ä»¶
COPY . .

# æ„å»º CPGï¼ˆç”Ÿæˆ JARï¼‰
RUN gradle clean build -x test

# è¿è¡Œæ—¶é•œåƒ
FROM openjdk:17-slim

WORKDIR /app

# å¤åˆ¶ JAR å’Œä¾èµ–
COPY --from=builder /cpg/cpg-core/build/libs/cpg-core-*.jar /app/cpg-core.jar
COPY --from=builder /cpg/cpg-core/build/libs/libs/*.jar /app/libs/

# å®‰è£… Gitï¼ˆå…‹éš†ä»“åº“éœ€è¦ï¼‰
RUN apt-get update && apt-get install -y git && rm -rf /var/lib/apt/lists/*

# å¤åˆ¶ entrypoint è„šæœ¬
COPY docker/build-container/entrypoint.sh /app/entrypoint.sh
RUN chmod +x /app/entrypoint.sh

# è®¾ç½®è¾“å‡ºç›®å½•
VOLUME ["/output"]

# å…¥å£ç‚¹
ENTRYPOINT ["/app/entrypoint.sh"]
```

---

#### 3.1.2 entrypoint.sh

**æ–‡ä»¶**ï¼š`docker/build-container/entrypoint.sh`

```bash
#!/bin/bash
set -e

# è¯»å–ç¯å¢ƒå˜é‡
GIT_REPO=${GIT_REPO:-}
GIT_REF=${GIT_REF:-main}
PASSES=${PASSES:-}
LANGUAGES=${LANGUAGES:-java}
OUTPUT_PATH=${OUTPUT_PATH:-/output/graph.dump}
SOURCE_INCLUDES=${SOURCE_INCLUDES:-**/*.java,**/*.kt}
SOURCE_EXCLUDES=${SOURCE_EXCLUDES:-**/test/**,**/generated/**}

# éªŒè¯å¿…éœ€ç¯å¢ƒå˜é‡
if [ -z "$GIT_REPO" ]; then
    echo "âŒ Error: GIT_REPO is required"
    exit 1
fi

if [ -z "$PASSES" ]; then
    echo "âŒ Error: PASSES is required"
    exit 1
fi

# æ‰“å°é…ç½®
echo "========================================="
echo "CPG Build Container"
echo "========================================="
echo "GIT_REPO: $GIT_REPO"
echo "GIT_REF: $GIT_REF"
echo "PASSES: $PASSES"
echo "LANGUAGES: $LANGUAGES"
echo "OUTPUT_PATH: $OUTPUT_PATH"
echo "========================================="

# 1. å…‹éš† Git ä»“åº“
echo "ğŸ“¥ Cloning repository..."
REPO_DIR=/tmp/repo
git clone --depth 1 --branch "$GIT_REF" "$GIT_REPO" "$REPO_DIR" || {
    echo "âŒ Failed to clone repository"
    exit 1
}

# 2. è¿è¡Œ CPG æ„å»º
echo "ğŸ”§ Building CPG graph..."
java -jar /app/cpg-core.jar \
    --source "$REPO_DIR" \
    --languages "$LANGUAGES" \
    --passes "$PASSES" \
    --source-includes "$SOURCE_INCLUDES" \
    --source-excludes "$SOURCE_EXCLUDES" \
    --output "$OUTPUT_PATH" || {
    echo "âŒ Failed to build CPG graph"
    exit 1
}

# 3. éªŒè¯è¾“å‡ºæ–‡ä»¶
if [ ! -f "$OUTPUT_PATH" ]; then
    echo "âŒ Output file not found: $OUTPUT_PATH"
    exit 1
fi

echo "âœ… Build completed successfully!"
echo "   - Graph: $OUTPUT_PATH"
echo "   - Config: $OUTPUT_PATH.config.json"
echo "   - Stats: $OUTPUT_PATH.stats.json"

# æ‰“å°ç»Ÿè®¡ä¿¡æ¯
if [ -f "$OUTPUT_PATH.stats.json" ]; then
    echo "========================================="
    echo "Build Statistics:"
    cat "$OUTPUT_PATH.stats.json" | jq .
    echo "========================================="
fi
```

---

#### 3.1.3 æ„å»ºé•œåƒ

```bash
# æ„å»ºé•œåƒ
docker build -t cpg-builder:v1.0 -f docker/build-container/Dockerfile .

# æµ‹è¯•é•œåƒ
docker run --rm \
  -e GIT_REPO=https://github.com/user/repo.git \
  -e GIT_REF=main \
  -e PASSES=EvaluationOrderGraphPass,ControlFlowSensitiveDFGPass,UnreachableEOGPass \
  -e LANGUAGES=java \
  -v $(pwd)/output:/output \
  cpg-builder:v1.0
```

---

### 3.2 Step 2: æŸ¥è¯¢å®¹å™¨å®ç°ï¼ˆ2-3 å¤©ï¼‰

#### 3.2.1 Dockerfile

**æ–‡ä»¶**ï¼š`docker/query-container/Dockerfile`

```dockerfile
FROM openjdk:17-slim

WORKDIR /app

# å¤åˆ¶æŸ¥è¯¢è¿è¡Œå™¨ JAR
COPY docker/query-container/cpg-query.jar /app/cpg-query.jar

# å¤åˆ¶ Kotlin Scripting Engine ä¾èµ–
COPY docker/query-container/libs/*.jar /app/libs/

# è®¾ç½®è¾“å…¥/è¾“å‡ºç›®å½•
VOLUME ["/input", "/queries", "/output"]

# å…¥å£ç‚¹
ENTRYPOINT ["java", "-jar", "/app/cpg-query.jar"]
```

---

#### 3.2.2 QueryRunner.ktï¼ˆæŸ¥è¯¢è¿è¡Œå™¨ä¸»ç¨‹åºï¼‰

**æ–‡ä»¶**ï¼š`docker/query-container/src/main/kotlin/QueryRunner.kt`

```kotlin
package de.fraunhofer.aisec.cpg.query

import de.fraunhofer.aisec.cpg.TranslationResult
import de.fraunhofer.aisec.cpg.persistence.deserialize
import kotlin.script.experimental.api.*
import kotlin.script.experimental.jvm.*
import kotlin.script.experimental.host.toScriptSource
import java.io.File
import kotlin.system.exitProcess

fun main() {
    try {
        // 1. è¯»å–ç¯å¢ƒå˜é‡
        val graphPath = System.getenv("GRAPH_PATH")
            ?: error("GRAPH_PATH environment variable is required")
        val queryScript = System.getenv("QUERY_SCRIPT")
            ?: error("QUERY_SCRIPT environment variable is required")
        val outputPath = System.getenv("OUTPUT_PATH") ?: "/output/result.json"
        val timeout = System.getenv("QUERY_TIMEOUT")?.toIntOrNull() ?: 300  // é»˜è®¤ 5 åˆ†é’Ÿ

        println("========================================")
        println("CPG Query Container")
        println("========================================")
        println("GRAPH_PATH: $graphPath")
        println("QUERY_SCRIPT: $queryScript")
        println("OUTPUT_PATH: $outputPath")
        println("QUERY_TIMEOUT: $timeout seconds")
        println("========================================")

        // 2. åŠ è½½å›¾
        println("ğŸ“¥ Loading graph from $graphPath...")
        val result = TranslationResult.deserialize(graphPath, validateConfig = true)
        println("âœ… Graph loaded successfully")

        // 3. æ‰§è¡ŒæŸ¥è¯¢è„šæœ¬
        println("ğŸ” Executing query script: $queryScript...")
        val executor = QueryScriptExecutor(result)
        val queryResult = executor.executeScript(File(queryScript), timeout)

        // 4. å†™å…¥ç»“æœ
        println("ğŸ“¤ Writing results to $outputPath...")
        File(outputPath).writeText(
            com.google.gson.GsonBuilder()
                .setPrettyPrinting()
                .create()
                .toJson(queryResult.data)
        )

        println("âœ… Query completed successfully!")
        exitProcess(0)

    } catch (e: Exception) {
        println("âŒ Query failed: ${e.message}")
        e.printStackTrace()
        exitProcess(1)
    }
}

/**
 * æŸ¥è¯¢è„šæœ¬æ‰§è¡Œå™¨
 */
class QueryScriptExecutor(private val result: TranslationResult) {

    private val outputBuffer = mutableListOf<Any>()

    data class QueryResult(
        val success: Boolean,
        val data: List<Any> = emptyList(),
        val errors: List<String> = emptyList()
    )

    fun executeScript(scriptFile: File, timeoutSeconds: Int): QueryResult {
        require(scriptFile.exists()) { "Script file not found: ${scriptFile.absolutePath}" }

        val scriptEngine = KotlinJvmScriptEngine()

        val evalResult = scriptEngine.eval(
            script = scriptFile.toScriptSource(),
            compilation = ScriptCompilationConfiguration {
                // é»˜è®¤ import CPG API
                defaultImports(
                    "de.fraunhofer.aisec.cpg.graph.*",
                    "de.fraunhofer.aisec.cpg.graph.statements.*",
                    "de.fraunhofer.aisec.cpg.graph.edges.flows.*",
                    "de.fraunhofer.aisec.cpg.query.*"
                )
            },
            evaluation = ScriptEvaluationConfiguration {
                // æ³¨å…¥å˜é‡
                providedProperties(
                    "result" to result,
                    "config" to result.config,
                    "output" to ::recordOutput,
                    "log" to ::log
                )
            }
        )

        return when (evalResult) {
            is ResultWithDiagnostics.Success ->
                QueryResult(success = true, data = outputBuffer)
            is ResultWithDiagnostics.Failure ->
                QueryResult(
                    success = false,
                    errors = evalResult.reports.map { it.message }
                )
        }
    }

    private fun recordOutput(data: Any) {
        outputBuffer.add(data)
    }

    private fun log(message: String) {
        println("[QUERY] $message")
    }
}
```

---

#### 3.2.3 ç¤ºä¾‹æŸ¥è¯¢è„šæœ¬

**æ–‡ä»¶**ï¼š`docker/query-container/examples/find-unreachable-code.kts`

```kotlin
// find-unreachable-code.kts
// æŸ¥æ‰¾ä¸å¯è¾¾ä»£ç 

import de.fraunhofer.aisec.cpg.graph.statements.IfStatement
import de.fraunhofer.aisec.cpg.graph.edges.flows.EvaluationOrder

// æŸ¥æ‰¾æ‰€æœ‰ if è¯­å¥
val ifStatements = result.allNodes<IfStatement>()

log("Found ${ifStatements.size} if statements")

// æŸ¥æ‰¾åŒ…å«ä¸å¯è¾¾åˆ†æ”¯çš„ if è¯­å¥
val unreachableBranches = ifStatements.filter { ifStmt ->
    ifStmt.nextEOGEdges.any { edge ->
        edge is EvaluationOrder && edge.unreachable == true
    }
}

log("Found ${unreachableBranches.size} unreachable branches")

// è¾“å‡ºç»“æœ
output(mapOf(
    "totalIfStatements" to ifStatements.size,
    "unreachableBranches" to unreachableBranches.map { ifStmt ->
        mapOf(
            "file" to ifStmt.location?.artifactLocation?.uri,
            "line" to ifStmt.location?.region?.startLine,
            "code" to ifStmt.code
        )
    }
))
```

---

#### 3.2.4 æ„å»ºæŸ¥è¯¢å®¹å™¨é•œåƒ

```bash
# ç¼–è¯‘æŸ¥è¯¢è¿è¡Œå™¨
./gradlew :cpg-query:build

# å¤åˆ¶ JAR å’Œä¾èµ–
cp cpg-query/build/libs/cpg-query-*.jar docker/query-container/cpg-query.jar
cp cpg-query/build/libs/libs/*.jar docker/query-container/libs/

# æ„å»ºé•œåƒ
docker build -t cpg-query:v1.0 -f docker/query-container/Dockerfile .

# æµ‹è¯•é•œåƒ
docker run --rm \
  -e GRAPH_PATH=/input/graph.dump \
  -e QUERY_SCRIPT=/queries/find-unreachable-code.kts \
  -e OUTPUT_PATH=/output/result.json \
  -v $(pwd)/output:/input:ro \
  -v $(pwd)/docker/query-container/examples:/queries:ro \
  -v $(pwd)/query-results:/output \
  cpg-query:v1.0
```

---

### 3.3 Step 3: Docker Compose ç¼–æ’ï¼ˆ1-2 å¤©ï¼‰

#### 3.3.1 docker-compose.yml

**æ–‡ä»¶**ï¼š`docker-compose.yml`

```yaml
version: '3.8'

services:
  # æ„å»ºå®¹å™¨ï¼ˆè¿è¡Œä¸€æ¬¡ï¼‰
  builder:
    image: cpg-builder:v1.0
    environment:
      - GIT_REPO=${GIT_REPO}
      - GIT_REF=${GIT_REF:-main}
      - PASSES=${PASSES}
      - LANGUAGES=${LANGUAGES:-java}
      - OUTPUT_PATH=/output/graph.dump
    volumes:
      - graph-data:/output

  # æŸ¥è¯¢å®¹å™¨ï¼ˆå¯æ‰©å±•å¤šå®ä¾‹ï¼‰
  query:
    image: cpg-query:v1.0
    environment:
      - GRAPH_PATH=/input/graph.dump
      - QUERY_SCRIPT=/queries/${QUERY_NAME}.kts
      - OUTPUT_PATH=/output/${QUERY_NAME}-result.json
    volumes:
      - graph-data:/input:ro      # åªè¯»
      - ./queries:/queries:ro      # ç”¨æˆ·è„šæœ¬
      - ./results:/output          # è¾“å‡ºç›®å½•
    depends_on:
      - builder
    deploy:
      replicas: 3  # å¹¶å‘ 3 ä¸ªæŸ¥è¯¢å®¹å™¨

volumes:
  graph-data:
```

---

#### 3.3.2 .env é…ç½®æ–‡ä»¶

**æ–‡ä»¶**ï¼š`.env`

```bash
# æ„å»ºé…ç½®
GIT_REPO=https://github.com/user/repo.git
GIT_REF=main
PASSES=EvaluationOrderGraphPass,ControlFlowSensitiveDFGPass,UnreachableEOGPass
LANGUAGES=java,kotlin

# æŸ¥è¯¢é…ç½®
QUERY_NAME=find-unreachable-code
```

---

#### 3.3.3 ä½¿ç”¨ç¤ºä¾‹

```bash
# 1. å¯åŠ¨æ„å»ºå®¹å™¨
docker-compose up builder

# 2. å¯åŠ¨æŸ¥è¯¢å®¹å™¨ï¼ˆ3 ä¸ªå®ä¾‹ï¼‰
docker-compose up --scale query=3 query

# 3. æŸ¥çœ‹ç»“æœ
cat results/find-unreachable-code-result.json | jq .
```

---

## 4. æµ‹è¯•è®¡åˆ’

### 4.1 å•å…ƒæµ‹è¯•

| æµ‹è¯•ç±» | è¦†ç›–èŒƒå›´ | ç›®æ ‡ |
|--------|---------|------|
| `SerializationTest` | åºåˆ—åŒ– API | æµ‹è¯•å°å‹å›¾åºåˆ—åŒ– |
| `DeserializationTest` | ååºåˆ—åŒ– API | æµ‹è¯•å°å‹å›¾ååºåˆ—åŒ– |
| `RoundtripTest` | å¾€è¿”æµ‹è¯• | éªŒè¯åºåˆ—åŒ– â†’ ååºåˆ—åŒ–ä¸€è‡´æ€§ |
| `PerformanceTest` | æ€§èƒ½æµ‹è¯• | éªŒè¯å¤§å‹å›¾æ€§èƒ½ç›®æ ‡ |

**è¿è¡Œæµ‹è¯•**ï¼š
```bash
./gradlew :cpg-core:test
```

---

### 4.2 é›†æˆæµ‹è¯•

| æµ‹è¯•åœºæ™¯ | éªŒè¯å†…å®¹ |
|---------|---------|
| æ„å»ºå®¹å™¨ E2E | Git å…‹éš† â†’ æ„å»ºå›¾ â†’ åºåˆ—åŒ– â†’ éªŒè¯äº§ç‰© |
| æŸ¥è¯¢å®¹å™¨ E2E | åŠ è½½å›¾ â†’ æ‰§è¡Œ .kts â†’ è¾“å‡ºç»“æœ â†’ éªŒè¯æ ¼å¼ |
| Docker Compose | æ„å»º â†’ æŸ¥è¯¢ â†’ å¹¶å‘æ‰§è¡Œ â†’ éªŒè¯ç»“æœ |

**è¿è¡Œé›†æˆæµ‹è¯•**ï¼š
```bash
# æµ‹è¯•æ„å»ºå®¹å™¨
./test-scripts/test-builder.sh

# æµ‹è¯•æŸ¥è¯¢å®¹å™¨
./test-scripts/test-query.sh

# æµ‹è¯• Docker Compose
./test-scripts/test-compose.sh
```

---

### 4.3 æ€§èƒ½æµ‹è¯•

| æŒ‡æ ‡ | ç›®æ ‡ | æµ‹è¯•æ•°æ® |
|------|------|---------|
| åºåˆ—åŒ–è€—æ—¶ | â‰¤ 30 ç§’ | 50K èŠ‚ç‚¹å›¾ |
| ååºåˆ—åŒ–è€—æ—¶ | â‰¤ 60 ç§’ | 50K èŠ‚ç‚¹å›¾ |
| æ–‡ä»¶å¤§å° | â‰¤ 100 MB | 10K LOC é¡¹ç›® |
| æŸ¥è¯¢å“åº”æ—¶é—´ | â‰¤ å•ä½“è¿è¡Œçš„ 1.1x | executionPath æŸ¥è¯¢ |

---

## 5. éªŒæ”¶æ ‡å‡†

### 5.1 åŠŸèƒ½æ€§éªŒæ”¶

| åŠŸèƒ½ | éªŒæ”¶æ–¹æ³• |
|------|---------|
| âœ… æ„å»ºä¸æŸ¥è¯¢è§£è€¦ | æ„å»ºå®¹å™¨å’ŒæŸ¥è¯¢å®¹å™¨å¯åœ¨ä¸åŒæœºå™¨è¿è¡Œ |
| âœ… å›¾åºåˆ—åŒ–å®Œæ•´æ€§ | å¾€è¿”æµ‹è¯•é€šè¿‡ï¼ˆèŠ‚ç‚¹æ•°ã€è¾¹æ•°ã€å±æ€§ä¸€è‡´ï¼‰|
| âœ… Pass é…ç½®éªŒè¯ | æŸ¥è¯¢æ—¶ä½¿ç”¨æœªæ³¨å†Œ Pass æŠ›å‡ºæ¸…æ™°é”™è¯¯ |
| âœ… å¹¶å‘æŸ¥è¯¢éš”ç¦» | 10 ä¸ªæŸ¥è¯¢å®¹å™¨å¹¶å‘æŸ¥è¯¢æ— å†²çª |
| âœ… Kotlin Script æ‰§è¡Œ | ç”¨æˆ·å¯ç¼–å†™ .kts è„šæœ¬å¹¶æ‰§è¡Œ |

---

### 5.2 æ€§èƒ½éªŒæ”¶

| æŒ‡æ ‡ | ç›®æ ‡ | å®é™… | é€šè¿‡ |
|------|------|------|------|
| åºåˆ—åŒ–è€—æ—¶ | â‰¤ 30 ç§’ | [å¾…æµ‹è¯•] | [ ] |
| ååºåˆ—åŒ–è€—æ—¶ | â‰¤ 60 ç§’ | [å¾…æµ‹è¯•] | [ ] |
| æ–‡ä»¶å¤§å° | â‰¤ 100 MB | [å¾…æµ‹è¯•] | [ ] |
| æŸ¥è¯¢å“åº”æ—¶é—´ | â‰¤ 1.1x | [å¾…æµ‹è¯•] | [ ] |

---

### 5.3 æ˜“ç”¨æ€§éªŒæ”¶

| æ ‡å‡† | éªŒæ”¶æ–¹æ³• |
|------|---------|
| âœ… å¿«é€Ÿå¼€å§‹ | æ–°ç”¨æˆ· 5 åˆ†é’Ÿå†…å®Œæˆç¬¬ä¸€æ¬¡æ„å»º+æŸ¥è¯¢ |
| âœ… é”™è¯¯æç¤ºæ¸…æ™° | æ‰€æœ‰å¸¸è§é”™è¯¯æœ‰æ¸…æ™°æç¤º |
| âœ… æ–‡æ¡£å®Œæ•´ | æ¶æ„è®¾è®¡ã€å®ç°æŒ‡å—ã€ç”¨æˆ·æ‰‹å†Œé½å…¨ |

---

## 6. æ•…éšœæ’æŸ¥

### 6.1 å¸¸è§é—®é¢˜

#### é—®é¢˜ 1: åºåˆ—åŒ–å¤±è´¥ï¼ˆOutOfMemoryErrorï¼‰

**ç—‡çŠ¶**ï¼š
```
java.lang.OutOfMemoryError: Java heap space
```

**åŸå› **ï¼šå›¾è¿‡å¤§ï¼Œå†…å­˜ä¸è¶³

**è§£å†³æ–¹æ¡ˆ**ï¼š
```bash
# å¢åŠ  JVM å †å†…å­˜
export JAVA_OPTS="-Xmx8g -Xms4g"
docker run --rm -e JAVA_OPTS="$JAVA_OPTS" ...
```

---

#### é—®é¢˜ 2: ååºåˆ—åŒ–å¤±è´¥ï¼ˆClassNotFoundExceptionï¼‰

**ç—‡çŠ¶**ï¼š
```
java.lang.ClassNotFoundException: de.fraunhofer.aisec.cpg.graph.Node
```

**åŸå› **ï¼šåºåˆ—åŒ–å’Œååºåˆ—åŒ–ä½¿ç”¨çš„ CPG ç‰ˆæœ¬ä¸ä¸€è‡´

**è§£å†³æ–¹æ¡ˆ**ï¼š
- éªŒè¯æ„å»ºå®¹å™¨å’ŒæŸ¥è¯¢å®¹å™¨ä½¿ç”¨ç›¸åŒçš„ CPG ç‰ˆæœ¬
- æ£€æŸ¥ `config.json` ä¸­çš„ç‰ˆæœ¬ä¿¡æ¯

---

#### é—®é¢˜ 3: æŸ¥è¯¢è„šæœ¬ç¼–è¯‘å¤±è´¥

**ç—‡çŠ¶**ï¼š
```
error: unresolved reference: TranslationResult
```

**åŸå› **ï¼šè„šæœ¬æ²¡æœ‰è‡ªåŠ¨ import CPG API

**è§£å†³æ–¹æ¡ˆ**ï¼š
- åœ¨ `ScriptCompilationConfiguration` ä¸­æ·»åŠ  `defaultImports`
- æˆ–åœ¨è„šæœ¬ä¸­æ‰‹åŠ¨ importï¼š
  ```kotlin
  import de.fraunhofer.aisec.cpg.TranslationResult
  ```

---

## 7. æ€»ç»“

### 7.1 å®æ–½æ—¶é—´çº¿æ€»ç»“

| Phase | ä»»åŠ¡ | æ—¶é—´ | çŠ¶æ€ |
|-------|------|------|------|
| **Phase 1** | åºåˆ—åŒ–/ååºåˆ—åŒ–å®ç° | 2-3 å‘¨ | â³ å¾…å¼€å§‹ |
| Step 1 | åºåˆ—åŒ–åº“è°ƒç ”ä¸é€‰å‹ | 2-3 å¤© | â³ å¾…å¼€å§‹ |
| Step 2 | æ ¸å¿ƒåºåˆ—åŒ–å®ç° | 1 å‘¨ | â³ å¾…å¼€å§‹ |
| Step 3 | ååºåˆ—åŒ–å®ç° | 1 å‘¨ | â³ å¾…å¼€å§‹ |
| Step 4 | ä¼˜åŒ–ï¼ˆå¯é€‰ï¼‰| 3-5 å¤© | â³ å¾…å¼€å§‹ |
| **Phase 2** | å®¹å™¨åŒ–æ‰“åŒ… | 1 å‘¨ | â³ å¾…å¼€å§‹ |
| Step 1 | æ„å»ºå®¹å™¨å®ç° | 2-3 å¤© | â³ å¾…å¼€å§‹ |
| Step 2 | æŸ¥è¯¢å®¹å™¨å®ç° | 2-3 å¤© | â³ å¾…å¼€å§‹ |
| Step 3 | Docker Compose ç¼–æ’ | 1-2 å¤© | â³ å¾…å¼€å§‹ |

**æ€»è®¡**ï¼š3-4 å‘¨

---

### 7.2 å…³é”®äº¤ä»˜ç‰©æ£€æŸ¥æ¸…å•

**ä»£ç äº¤ä»˜ç‰©**ï¼š
- [ ] `Serialization.kt` - åºåˆ—åŒ– API
- [ ] `Deserialization.kt` - ååºåˆ—åŒ– API
- [ ] å•å…ƒæµ‹è¯•ï¼ˆ`SerializationTest.kt`, `RoundtripTest.kt`, `PerformanceTest.kt`ï¼‰
- [ ] `Dockerfile` - æ„å»ºå®¹å™¨é•œåƒ
- [ ] `entrypoint.sh` - æ„å»ºå®¹å™¨å…¥å£è„šæœ¬
- [ ] `QueryRunner.kt` - æŸ¥è¯¢è¿è¡Œå™¨ä¸»ç¨‹åº
- [ ] `Dockerfile` - æŸ¥è¯¢å®¹å™¨é•œåƒ
- [ ] `docker-compose.yml` - å®¹å™¨ç¼–æ’é…ç½®
- [ ] ç¤ºä¾‹æŸ¥è¯¢è„šæœ¬ï¼ˆè‡³å°‘ 5 ä¸ª .kts æ–‡ä»¶ï¼‰

**æ–‡æ¡£äº¤ä»˜ç‰©**ï¼š
- [ ] 8.1-æ¶æ„-å®¹å™¨åŒ–è®¾è®¡.md
- [ ] 8.2-å®ç°-åˆ†æ­¥æŒ‡å—.mdï¼ˆæœ¬æ–‡æ¡£ï¼‰
- [ ] 8.3-æ‰‹å†Œ-ä½¿ç”¨æŒ‡å—.md
- [ ] 8.4-å‚è€ƒ-APIæ–‡æ¡£.md

---

### 7.3 ä¸‹ä¸€æ­¥

**é˜…è¯»ç›¸å…³æ–‡æ¡£**ï¼š
- **8.3-æ‰‹å†Œ-ä½¿ç”¨æŒ‡å—.md**ï¼šå¿«é€Ÿå¼€å§‹å’Œå¸¸è§é—®é¢˜
- **8.4-å‚è€ƒ-APIæ–‡æ¡£.md**ï¼šAPI ç­¾åå’Œç¯å¢ƒå˜é‡å‚è€ƒ

**å¼€å§‹å®æ–½**ï¼š
- ä» Phase 1 Step 1 å¼€å§‹ï¼ˆåºåˆ—åŒ–åº“è°ƒç ”ï¼‰
- æŒ‰ç…§æœ¬æ–‡æ¡£é€æ­¥å®æ–½
- æ¯ä¸ªæ­¥éª¤å®Œæˆåè¿è¡Œæµ‹è¯•éªŒè¯

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0
**æœ€åæ›´æ–°**: 2025-11-12
**ä¸‹ä¸€ç‰ˆæœ¬è®¡åˆ’**: æ·»åŠ  Kubernetes éƒ¨ç½²æŒ‡å—
