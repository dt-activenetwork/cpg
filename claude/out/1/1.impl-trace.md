# Java 前端实现代码追踪

本文档详细追踪 Java 前端的实现流程，包含完整的代码引用、文件路径和行号。所有代码引用都经过验证，可直接定位到源文件。

## 目录
- [1. 前端注册和初始化](#1-前端注册和初始化)
- [2. 解析入口和 JavaParser 配置](#2-解析入口和-javaparser-配置)
- [3. 包和命名空间处理](#3-包和命名空间处理)
- [4. 类和接口声明处理](#4-类和接口声明处理)
- [5. 方法声明处理](#5-方法声明处理)
- [6. 字段声明处理](#6-字段声明处理)
- [7. 语句处理示例](#7-语句处理示例)
- [8. 表达式处理示例](#8-表达式处理示例)
- [9. Java 特定 Pass 的实现](#9-java-特定-pass-的实现)
- [10. 完整示例追踪](#10-完整示例追踪)

---

## 1. 前端注册和初始化

### 1.1 语言定义和前端注册

**文件**: `cpg-language-java/src/main/kotlin/de/fraunhofer/aisec/cpg/frontends/java/JavaLanguage.kt`

**第 44-56 行**: 语言类定义
```kotlin
open class JavaLanguage :
    Language<JavaLanguageFrontend>(),
    HasClasses,
    HasSuperClasses,
    HasGenerics,
    HasQualifier,
    HasUnknownType,
    HasShortCircuitOperators,
    HasFunctionOverloading,
    HasImplicitReceiver {
    override val fileExtensions = listOf("java")
    override val namespaceDelimiter = "."
    override val frontend: KClass<out JavaLanguageFrontend> = JavaLanguageFrontend::class
    override val superClassKeyword = "super"
```

**解释**：
- 继承自 `Language<JavaLanguageFrontend>`，泛型参数指定前端类型
- 实现多个 trait 接口，声明 Java 语言的特性：
  - `HasClasses`: 支持类和接口
  - `HasGenerics`: 支持泛型 `List<String>`
  - `HasFunctionOverloading`: 支持方法重载
  - `HasImplicitReceiver`: 支持隐式 `this`
- `fileExtensions` 指定处理 `.java` 文件
- `namespaceDelimiter` 设置为 `.`（Java 包分隔符）

**第 77-95 行**: 内置类型定义
```kotlin
override val builtInTypes =
    mapOf(
        "void" to IncompleteType(),
        "boolean" to BooleanType("boolean", language = this),
        "byte" to IntegerType("byte", 8, this, NumericType.Modifier.SIGNED),
        "short" to IntegerType("short", 16, this, NumericType.Modifier.SIGNED),
        "int" to IntegerType("int", 32, this, NumericType.Modifier.SIGNED),
        "long" to IntegerType("long", 64, this, NumericType.Modifier.SIGNED),
        "float" to FloatingPointType("float", 32, this, NumericType.Modifier.SIGNED),
        "double" to FloatingPointType("double", 64, this, NumericType.Modifier.SIGNED),
        "char" to IntegerType("char", 16, this, NumericType.Modifier.UNSIGNED),
        // Object types
        "java.lang.Boolean" to ObjectType("Boolean", listOf(), false, this),
        "java.lang.Byte" to ObjectType("Byte", listOf(), false, this),
        "java.lang.Short" to ObjectType("Short", listOf(), false, this),
        "java.lang.Integer" to ObjectType("Integer", listOf(), false, this),
        "java.lang.Long" to ObjectType("Long", listOf(), false, this),
        "java.lang.Float" to ObjectType("Float", listOf(), false, this),
        "java.lang.Double" to ObjectType("Double", listOf(), false, this),
    )
```

**解释**：定义 Java 的基本类型和包装类型，供类型解析时使用。

### 1.2 前端类初始化

**文件**: `cpg-language-java/src/main/kotlin/de/fraunhofer/aisec/cpg/frontends/java/JavaLanguageFrontend.kt`

**第 79-85 行**: 类定义和 Pass 注册
```kotlin
@RegisterExtraPass(JavaExternalTypeHierarchyResolver::class)
@RegisterExtraPass(JavaImportResolver::class)
@RegisterExtraPass(JavaExtraPass::class)
open class JavaLanguageFrontend(
    ctx: TranslationContext,
    language: Language<JavaLanguageFrontend>
) : LanguageFrontend<Node, Type>(ctx, language)
```

**解释**：
- 使用 `@RegisterExtraPass` 注解注册三个 Java 特定的 pass
- 继承自 `LanguageFrontend<Node, Type>`：
  - 第一个泛型参数 `Node` 是 JavaParser 的 AST 节点类型
  - 第二个泛型参数 `Type` 是 JavaParser 的类型类型

**第 95-103 行**: Handler 初始化
```kotlin
init {
    setupHandlers()
}

private fun setupHandlers() {
    expressionHandler = ExpressionHandler(this)
    statementHandler = StatementHandler(this)
    declarationHandler = DeclarationHandler(this)
}
```

**解释**：在构造函数中初始化三个 Handler，传入 `this` 引用以便 Handler 访问前端的方法和字段。

**第 544-562 行**: JavaParser 符号解析器初始化
```kotlin
init {
    // 创建组合类型解析器
    val reflectionTypeSolver = ReflectionTypeSolver()
    nativeTypeResolver.add(reflectionTypeSolver)

    // 获取源文件根目录
    var root = ctx.currentComponent?.topLevel()
    if (root == null && config.softwareComponents.size == 1) {
        root = config.softwareComponents[config.softwareComponents.keys.first()]?.let {
            CommonPath.commonPath(it)
        }
    }

    if (root == null) {
        log.warn("Could not determine source root for {}", config.softwareComponents)
    } else {
        log.info("Source file root used for type solver: {}", root)
        // 添加源文件类型解析器
        val javaParserTypeSolver = JavaParserTypeSolver(root)
        nativeTypeResolver.add(javaParserTypeSolver)
    }

    // 创建符号解析器
    javaSymbolResolver = JavaSymbolSolver(nativeTypeResolver)
}
```

**解释**：
- `ReflectionTypeSolver`: 解析 JDK 中的类（通过反射）
- `JavaParserTypeSolver`: 解析项目源码中的类
- `CombinedTypeSolver`: 组合多个解析器
- `JavaSymbolSolver`: JavaParser 的符号解析器，能解析类型、方法签名等

---

## 2. 解析入口和 JavaParser 配置

### 2.1 parse() 方法入口

**文件**: `cpg-language-java/src/main/kotlin/de/fraunhofer/aisec/cpg/frontends/java/JavaLanguageFrontend.kt`

**第 106-123 行**: 解析主流程
```kotlin
override fun parse(file: File): TranslationUnitDeclaration {
    // 配置 JavaParser
    val parserConfiguration = ParserConfiguration()
    parserConfiguration.setSymbolResolver(javaSymbolResolver)
    val parser = JavaParser(parserConfiguration)

    // 计时：解析源文件
    var bench = Benchmark(this.javaClass, "Parsing source file")
    context = parse(file, parser)  // 调用私有 parse() 方法
    bench.addMeasurement()

    // 计时：转换为 CPG
    bench = Benchmark(this.javaClass, "Transform to CPG")
    context?.setData(Node.SYMBOL_RESOLVER_KEY, javaSymbolResolver)

    // 创建 TranslationUnitDeclaration 根节点
    val tud = newTranslationUnitDeclaration(file.toString(), rawNode = context)
```

**第 187-203 行**: 私有 parse() 方法（调用 JavaParser）
```kotlin
private fun parse(file: File, parser: JavaParser): CompilationUnit? {
    return try {
        val result = parser.parse(file)
        if (result.isSuccessful) {
            val problems = result.problems
            if (problems.isNotEmpty()) {
                log.debug(
                    "Parsing of {} was successful but with {} problems",
                    file,
                    problems.size
                )
                for (problem in problems) {
                    log.debug(" - {}", problem)
                }
            }
            result.result.orElse(null)
        } else {
            log.error("Parsing of {} failed with {} problems", file, result.problems.size)
            for (problem in result.problems) {
                log.error(" - {}", problem)
            }
            null
        }
    } catch (e: IOException) {
        log.error("Could not parse file {}", file, e)
        null
    }
}
```

**解释**：
- 使用 `JavaParser.parse(file)` 解析源文件
- 检查解析结果，记录任何问题（warnings）
- 即使有问题，只要解析成功就返回 `CompilationUnit`
- 这就是宽容式解析的体现

### 2.2 创建 TranslationUnitDeclaration

**第 119 行**: 创建根节点
```kotlin
val tud = newTranslationUnitDeclaration(file.toString(), rawNode = context)
```

**解释**：
- `newTranslationUnitDeclaration()` 是继承自 `DeclarationBuilder` 的工厂方法
- `rawNode` 参数保存原始的 JavaParser AST 节点，用于调试和位置信息提取
- 创建的节点会自动关联到当前的 `TranslationContext`

---

## 3. 包和命名空间处理

### 3.1 嵌套命名空间创建

**文件**: `cpg-language-java/src/main/kotlin/de/fraunhofer/aisec/cpg/frontends/java/JavaLanguageFrontend.kt`

**第 125-145 行**: 处理包声明
```kotlin
// 获取包声明（如果有）
val packDecl = context?.packageDeclaration?.orElse(null)

// 使用 fold 创建嵌套的 NamespaceDeclaration
val holder =
    packDecl?.name?.toString()?.split(language.namespaceDelimiter)?.fold(null) {
        previous: NamespaceDeclaration?,
        path ->
        // 构建全限定名
        var fqn = previous?.name.fqn(path)

        // 创建命名空间节点
        val nsd = newNamespaceDeclaration(fqn, rawNode = packDecl)
        scopeManager.addDeclaration(nsd)

        // 添加到父容器
        val holder = previous ?: tud
        holder.addDeclaration(nsd)

        // 进入新的命名空间作用域
        scopeManager.enterScope(nsd)
        nsd  // 返回当前命名空间，作为下一次迭代的 previous
    } ?: tud  // 如果没有包声明，使用 tud 作为容器
```

**示例**：
假设包声明为 `package com.example.app;`

**执行流程**：
1. `split(".")` -> `["com", "example", "app"]`
2. 第一次迭代：
   - `path = "com"`, `previous = null`
   - `fqn = "com"`
   - 创建 `NamespaceDeclaration("com")`
   - 添加到 `tud`
   - 返回 `nsd1`
3. 第二次迭代：
   - `path = "example"`, `previous = nsd1`
   - `fqn = "com.example"`
   - 创建 `NamespaceDeclaration("com.example")`
   - 添加到 `nsd1`
   - 返回 `nsd2`
4. 第三次迭代：
   - `path = "app"`, `previous = nsd2`
   - `fqn = "com.example.app"`
   - 创建 `NamespaceDeclaration("com.example.app")`
   - 添加到 `nsd2`
   - 返回 `nsd3`

**结果 CPG 结构**：
```
TranslationUnitDeclaration
└── NamespaceDeclaration(com)
    └── NamespaceDeclaration(com.example)
        └── NamespaceDeclaration(com.example.app)
```

### 3.2 处理类型声明

**第 145-153 行**: 遍历所有类型声明
```kotlin
// holder 是最内层的命名空间（或 tud）
for (type in context?.types ?: listOf()) {
    // 调用 DeclarationHandler 处理每个类型
    val declaration = declarationHandler.handle(type)
    if (declaration != null) {
        // 注册到作用域
        scopeManager.addDeclaration(declaration)
        // 添加到命名空间
        holder.addDeclaration(declaration)
    }
}
```

**第 155-180 行**: 处理 import 语句
```kotlin
// 处理普通 import
for (importDecl in context?.imports ?: listOf()) {
    val code = importDecl.name.toString()
    scopeManager.addImportDeclaration(importDecl.name.asString())
    scopeManager.currentRecord?.importStatements?.add(code)
}

// 处理静态 import
val staticImports = context?.imports?.filter { it.isStatic } ?: listOf()
for (importDecl in staticImports) {
    val code = importDecl.name.toString()
    if (importDecl.isAsterisk) {
        scopeManager.currentRecord?.staticImportStatements?.add("$code.*")
    } else {
        scopeManager.currentRecord?.staticImportStatements?.add(code)
    }
}
```

---

## 4. 类和接口声明处理

### 4.1 handleClassOrInterfaceDeclaration 方法

**文件**: `cpg-language-java/src/main/kotlin/de/fraunhofer/aisec/cpg/frontends/java/DeclarationHandler.kt`

**第 173-212 行**: 处理类/接口声明
```kotlin
fun handleClassOrInterfaceDeclaration(
    classInterDecl: ClassOrInterfaceDeclaration
): RecordDeclaration {
    // 获取全限定名
    val fqn = classInterDecl.fullyQualifiedName.orElse(classInterDecl.nameAsString)

    // 创建 RecordDeclaration 节点
    val recordDeclaration = this.newRecordDeclaration(fqn, "class", rawNode = classInterDecl)

    // 处理父类
    recordDeclaration.superClasses =
        classInterDecl.extendedTypes
            .map { type -> frontend.getTypeAsGoodAsPossible(type) }
            .toMutableList()

    // 处理实现的接口
    recordDeclaration.implementedInterfaces =
        classInterDecl.implementedTypes
            .map { type -> frontend.getTypeAsGoodAsPossible(type) }
            .toMutableList()

    // 处理泛型类型参数
    frontend.typeManager.addTypeParameter(
        recordDeclaration,
        classInterDecl.typeParameters.map { ParameterizedType(it.nameAsString, language) },
    )

    // 处理 import 声明
    processImportDeclarations(recordDeclaration)

    // 进入类的作用域
    frontend.scopeManager.enterScope(recordDeclaration)

    // 处理类成员（字段、方法、构造函数、嵌套类）
    processRecordMembers(classInterDecl, recordDeclaration)

    // 离开类的作用域
    frontend.scopeManager.leaveScope(recordDeclaration)

    return recordDeclaration
}
```

### 4.2 processRecordMembers 方法

**第 328-384 行**: 处理类成员
```kotlin
private fun <T : TypeDeclaration<T>> processRecordMembers(
    typeDecl: T,
    recordDeclaration: RecordDeclaration,
) {
    for (decl in typeDecl.members) {
        when (decl) {
            // 处理方法
            is MethodDeclaration -> {
                val md = handle(decl) as MethodDeclaration
                frontend.scopeManager.addDeclaration(md)
                recordDeclaration.methods += md
            }
            // 处理字段
            is com.github.javaparser.ast.body.FieldDeclaration -> {
                val seq = handle(decl) as DeclarationSequence
                seq.declarations.filterIsInstance<FieldDeclaration>().forEach {
                    frontend.scopeManager.addDeclaration(it)
                    recordDeclaration.fields += it
                }
            }
            // 处理构造函数
            is ConstructorDeclaration -> {
                val c = handle(decl) as ConstructorDeclaration
                frontend.scopeManager.addDeclaration(c)
                recordDeclaration.constructors += c
            }
            // 处理嵌套类
            is ClassOrInterfaceDeclaration -> {
                val r = handle(decl) as RecordDeclaration
                frontend.scopeManager.addDeclaration(r)
                recordDeclaration.records += r
            }
            // 处理嵌套枚举
            is EnumDeclaration -> {
                val r = handle(decl) as EnumDeclaration
                frontend.scopeManager.addDeclaration(r)
                recordDeclaration.records += r
            }
            // 处理初始化块
            is InitializerDeclaration -> {
                // 创建隐式方法表示初始化块
                val name = if (decl.isStatic) "<clinit>" else "<init>"
                val initializer = newMethodDeclaration(name, isStatic = decl.isStatic, recordDeclaration = recordDeclaration)
                initializer.isImplicit = true
                frontend.scopeManager.enterScope(initializer)
                initializer.body = frontend.statementHandler.handle(decl.body)
                frontend.scopeManager.leaveScope(initializer)
                frontend.scopeManager.addDeclaration(initializer)
                recordDeclaration.methods += initializer
            }
        }
    }

    // 如果没有显式构造函数，创建默认构造函数
    if (recordDeclaration.constructors.isEmpty()) {
        val constructorDeclaration =
            newConstructorDeclaration(
                recordDeclaration.name.localName,
                recordDeclaration,
                rawNode = typeDecl,
            ).implicit(recordDeclaration.name.localName)

        frontend.scopeManager.addDeclaration(constructorDeclaration)
        recordDeclaration.constructors += constructorDeclaration
    }
}
```

**解释**：
- 使用 Kotlin 的 `when` 表达式根据成员类型分发处理
- 每种成员处理后都会：
  1. 添加到 `scopeManager`（用于符号解析）
  2. 添加到 `recordDeclaration` 的对应列表（建立 AST 父子关系）
- 初始化块被转换为隐式方法：
  - 静态初始化块 -> `<clinit>` 方法
  - 实例初始化块 -> `<init>` 方法
- 自动生成默认构造函数（如果没有显式定义）

### 4.3 枚举声明处理

**第 214-231 行**: handleEnumDeclaration
```kotlin
fun handleEnumDeclaration(enumDecl: EnumDeclaration): EnumDeclaration {
    val fqn = enumDecl.fullyQualifiedName.orElse(enumDecl.nameAsString)
    val declaration = newEnumDeclaration(fqn, rawNode = enumDecl)

    processImportDeclarations(declaration)

    frontend.scopeManager.enterScope(declaration)

    // 处理枚举常量
    for (entry in enumDecl.entries) {
        val constant = newEnumConstantDeclaration(entry.nameAsString, rawNode = entry)
        // 处理枚举常量的参数（如果有）
        for (arg in entry.arguments) {
            val expr = frontend.expressionHandler.handle(arg)
            constant.initializer = expr
        }
        frontend.scopeManager.addDeclaration(constant)
        declaration.entries += constant
    }

    // 处理枚举的成员（方法、字段等）
    processRecordMembers(enumDecl, declaration)

    frontend.scopeManager.leaveScope(declaration)
    return declaration
}
```

---

## 5. 方法声明处理

### 5.1 handleMethodDeclaration 方法

**文件**: `cpg-language-java/src/main/kotlin/de/fraunhofer/aisec/cpg/frontends/java/DeclarationHandler.kt`

**第 105-158 行**: 完整的方法声明处理
```kotlin
fun handleMethodDeclaration(
    methodDecl: MethodDeclaration
): de.fraunhofer.aisec.cpg.graph.declarations.MethodDeclaration {
    // 解析方法签名
    val resolvedMethod = methodDecl.resolve()
    val currentRecordDecl = frontend.scopeManager.currentRecord

    // 创建方法声明节点
    val functionDeclaration =
        this.newMethodDeclaration(
            resolvedMethod.name,
            methodDecl.isStatic,
            currentRecordDecl,
            rawNode = methodDecl,
        )

    // 进入方法作用域
    frontend.scopeManager.enterScope(functionDeclaration)

    // 创建方法接收者（this 参数）
    createMethodReceiver(currentRecordDecl, functionDeclaration)

    // 处理 throws 声明
    functionDeclaration.addThrowTypes(
        methodDecl.thrownExceptions.map { type: ReferenceType -> frontend.typeOf(type) }
    )

    // 处理参数
    for (parameter in methodDecl.parameters) {
        // 尝试解析泛型类型参数
        var resolvedType: Type? =
            frontend.typeManager.getTypeParameter(
                functionDeclaration.recordDeclaration,
                parameter.type.toString(),
            )

        // 如果不是泛型参数，解析实际类型
        if (resolvedType == null) {
            resolvedType = frontend.getTypeAsGoodAsPossible(parameter, parameter.resolve())
        }

        // 创建参数声明
        val param =
            this.newParameterDeclaration(
                parameter.nameAsString,
                resolvedType,
                parameter.isVarArgs,
                rawNode = parameter,
            )

        // 处理参数注解
        frontend.processAnnotations(param, parameter)

        // 注册参数
        frontend.scopeManager.addDeclaration(param)
        functionDeclaration.parameters += param
    }

    // 处理返回类型
    val returnTypes = listOf(frontend.getReturnTypeAsGoodAsPossible(methodDecl, resolvedMethod))
    functionDeclaration.returnTypes = returnTypes

    // 计算方法类型（函数签名类型）
    val type = computeType(functionDeclaration)
    functionDeclaration.type = type

    // 处理方法体
    val o = methodDecl.body
    if (o.isEmpty) {
        // 抽象方法或接口方法，没有方法体
        frontend.scopeManager.leaveScope(functionDeclaration)
        return functionDeclaration
    }

    val body = o.get()

    // 如果方法应该返回值但没有 return 语句，添加隐式 return
    addImplicitReturn(body)

    // 处理方法体语句
    functionDeclaration.body = frontend.statementHandler.handle(body)

    // 处理方法注解
    frontend.processAnnotations(functionDeclaration, methodDecl)

    // 离开方法作用域
    frontend.scopeManager.leaveScope(functionDeclaration)

    return functionDeclaration
}
```

### 5.2 创建方法接收者（this 参数）

**第 161-171 行**: createMethodReceiver
```kotlin
private fun createMethodReceiver(
    recordDeclaration: RecordDeclaration?,
    functionDeclaration: de.fraunhofer.aisec.cpg.graph.declarations.MethodDeclaration,
) {
    // 创建 this 变量
    val receiver =
        newVariableDeclaration("this", recordDeclaration?.toType() ?: unknownType(), false)
            .implicit("this")  // 标记为隐式声明

    // 注册 this 变量
    frontend.scopeManager.addDeclaration(receiver)

    // 设置为方法接收者
    functionDeclaration.receiver = receiver
}
```

**解释**：
- 为每个非静态方法创建一个隐式的 `this` 参数
- 类型为当前类的类型
- 注册到作用域中，使得方法体中可以引用 `this`

### 5.3 构造函数处理

**第 296-326 行**: handleConstructorDeclaration
```kotlin
fun handleConstructorDeclaration(
    constructorDecl: ConstructorDeclaration
): de.fraunhofer.aisec.cpg.graph.declarations.ConstructorDeclaration {
    val currentRecordDecl = frontend.scopeManager.currentRecord

    // 创建构造函数节点
    val declaration =
        this.newConstructorDeclaration(
            constructorDecl.nameAsString,
            currentRecordDecl,
            rawNode = constructorDecl,
        )

    frontend.scopeManager.enterScope(declaration)

    // 创建 this 参数
    createMethodReceiver(currentRecordDecl, declaration)

    // 处理参数
    for (parameter in constructorDecl.parameters) {
        val resolvedType = frontend.getTypeAsGoodAsPossible(parameter, parameter.resolve())
        val param =
            this.newParameterDeclaration(
                parameter.nameAsString,
                resolvedType,
                parameter.isVarArgs,
                rawNode = parameter,
            )
        frontend.processAnnotations(param, parameter)
        frontend.scopeManager.addDeclaration(param)
        declaration.parameters += param
    }

    // 处理方法体
    val body = frontend.statementHandler.handle(constructorDecl.body)
    declaration.body = body

    frontend.scopeManager.leaveScope(declaration)
    return declaration
}
```

---

## 6. 字段声明处理

### 6.1 handleFieldDeclaration 方法

**文件**: `cpg-language-java/src/main/kotlin/de/fraunhofer/aisec/cpg/frontends/java/DeclarationHandler.kt`

**第 233-294 行**: 处理字段声明
```kotlin
fun handleFieldDeclaration(
    fieldDecl: com.github.javaparser.ast.body.FieldDeclaration
): DeclarationSequence {
    // 创建声明序列（因为一个字段声明可能包含多个变量）
    val declarationSequence = DeclarationSequence()

    // 提取修饰符
    val modifiers = fieldDecl.modifiers.map { modifier -> modifier.keyword.asString() }

    // 处理每个变量
    for (variable in fieldDecl.variables) {
        // 处理初始化表达式
        val initializer =
            variable.initializer
                .map { ctx: Expression -> frontend.expressionHandler.handle(ctx) }
                .orElse(null)
                as? de.fraunhofer.aisec.cpg.graph.statements.expressions.Expression

        var type: Type
        try {
            // 尝试从类的泛型参数中解析类型
            type =
                frontend.typeManager.getTypeParameter(
                    frontend.scopeManager.currentRecord,
                    variable.resolve().type.describe(),
                ) ?: frontend.typeOf(variable.resolve().type)
        } catch (e: UnsolvedSymbolException) {
            // 类型解析失败，尝试从异常信息中恢复
            val t = frontend.recoverTypeFromUnsolvedException(e)
            type = if (t == null) {
                // 恢复失败，使用声明中的类型
                frontend.typeOf(variable.type)
            } else {
                // 恢复成功，但标记为猜测的类型
                this.objectType(t).apply { typeOrigin = Type.Origin.GUESSED }
            }
        }

        // 创建字段声明节点
        val fieldDeclaration =
            this.newFieldDeclaration(
                variable.name.asString(),
                type,
                modifiers,
                initializer,
                rawNode = fieldDecl,
            )

        // 处理注解
        frontend.processAnnotations(fieldDeclaration, fieldDecl)

        // 添加到声明序列
        declarationSequence.addDeclaration(fieldDeclaration)
    }

    return declarationSequence
}
```

**示例**：
对于 Java 代码：
```java
private int x = 1, y = 2;
```

处理流程：
1. 创建 `DeclarationSequence`
2. 提取修饰符：`["private"]`
3. 第一个变量 `x`：
   - 初始化器：`Literal(1)`
   - 创建 `FieldDeclaration("x", int, ["private"], Literal(1))`
4. 第二个变量 `y`：
   - 初始化器：`Literal(2)`
   - 创建 `FieldDeclaration("y", int, ["private"], Literal(2))`
5. 返回包含两个字段声明的序列

---

## 7. 语句处理示例

### 7.1 Handler 映射初始化

**文件**: `cpg-language-java/src/main/kotlin/de/fraunhofer/aisec/cpg/frontends/java/StatementHandler.kt`

**第 552-618 行**: 建立 AST 类型到处理方法的映射
```kotlin
init {
    map[IfStmt::class.java] = HandlerInterface { handleIfStatement(it) }
    map[AssertStmt::class.java] = HandlerInterface { handleAssertStatement(it) }
    map[WhileStmt::class.java] = HandlerInterface { handleWhileStatement(it) }
    map[DoStmt::class.java] = HandlerInterface { handleDoStatement(it) }
    map[ForEachStmt::class.java] = HandlerInterface { handleForEachStatement(it) }
    map[ForStmt::class.java] = HandlerInterface { handleForStatement(it) }
    map[BreakStmt::class.java] = HandlerInterface { handleBreakStatement(it) }
    map[ContinueStmt::class.java] = HandlerInterface { handleContinueStatement(it) }
    map[ReturnStmt::class.java] = HandlerInterface { handleReturnStatement(it) }
    map[BlockStmt::class.java] = HandlerInterface { handleBlockStatement(it) }
    map[LabeledStmt::class.java] = HandlerInterface { handleLabelStatement(it) }
    map[ExplicitConstructorInvocationStmt::class.java] =
        HandlerInterface { handleExplicitConstructorInvocation(it) }
    map[ExpressionStmt::class.java] = HandlerInterface { handleExpressionStatement(it) }
    map[SwitchStmt::class.java] = HandlerInterface { handleSwitchStatement(it) }
    map[EmptyStmt::class.java] = HandlerInterface { handleEmptyStatement(it) }
    map[SynchronizedStmt::class.java] = HandlerInterface { handleSynchronizedStatement(it) }
    map[TryStmt::class.java] = HandlerInterface { handleTryStatement(it) }
    map[ThrowStmt::class.java] = HandlerInterface { handleThrowStmt(it) }
    map[LocalClassDeclarationStmt::class.java] =
        HandlerInterface { handleLocalClassDeclarationStatement(it) }
}
```

### 7.2 If 语句处理

**第 112-126 行**: handleIfStatement
```kotlin
private fun handleIfStatement(stmt: Statement): IfStatement {
    val ifStmt = stmt.asIfStmt()

    // 提取各部分
    val conditionExpression = ifStmt.condition
    val thenStatement = ifStmt.thenStmt
    val optionalElseStatement = ifStmt.elseStmt

    // 创建 IfStatement 节点
    val ifStatement = newIfStatement(rawNode = stmt)

    // 进入 if 语句作用域
    frontend.scopeManager.enterScope(ifStatement)

    // 处理 then 分支
    ifStatement.thenStatement = handle(thenStatement)

    // 处理条件表达式
    ifStatement.condition =
        frontend.expressionHandler.handle(conditionExpression)
            as de.fraunhofer.aisec.cpg.graph.statements.expressions.Expression

    // 处理 else 分支（如果有）
    optionalElseStatement.ifPresent { ifStatement.elseStatement = handle(it) }

    // 离开作用域
    frontend.scopeManager.leaveScope(ifStatement)

    return ifStatement
}
```

### 7.3 ForEach 语句处理

**第 156-171 行**: handleForEachStatement
```kotlin
private fun handleForEachStatement(stmt: Statement): ForEachStatement {
    val statement = newForEachStatement(rawNode = stmt)

    // 进入 for-each 作用域
    frontend.scopeManager.enterScope(statement)

    val forEachStmt = stmt.asForEachStmt()

    // 处理循环变量声明
    val variable = frontend.expressionHandler.handle(forEachStmt.variable)

    // 处理可迭代对象
    val iterable = frontend.expressionHandler.handle(forEachStmt.iterable)

    if (variable !is DeclarationStatement) {
        log.error("Expected a DeclarationStatement but received: {}", variable?.name)
    } else {
        statement.variable = variable
    }

    statement.iterable = iterable

    // 处理循环体
    statement.statement = handle(forEachStmt.body)

    frontend.scopeManager.leaveScope(statement)

    return statement
}
```

### 7.4 Try-Catch-Finally 处理

**第 486-526 行**: handleTryStatement
```kotlin
private fun handleTryStatement(stmt: Statement): TryStatement {
    val tryStmt = stmt.asTryStmt()

    // 创建 try 语句节点
    val tryStatement = newTryStatement(rawNode = stmt)

    frontend.scopeManager.enterScope(tryStatement)

    // 处理 try-with-resources 资源
    val resources =
        tryStmt.resources
            .mapNotNull { ctx -> frontend.expressionHandler.handle(ctx) }
            .toMutableList()

    // 处理 try 块
    val tryBlock = handleBlockStatement(tryStmt.tryBlock)

    // 处理 catch 子句
    val catchClauses = tryStmt.catchClauses.map(::handleCatchClause).toMutableList()

    // 处理 finally 块
    val finallyBlock = tryStmt.finallyBlock.map(::handleBlockStatement).orElse(null)

    frontend.scopeManager.leaveScope(tryStatement)

    // 设置各部分
    tryStatement.resources = resources
    tryStatement.tryBlock = tryBlock
    tryStatement.finallyBlock = finallyBlock
    tryStatement.catchClauses = catchClauses

    return tryStatement
}
```

**第 528-550 行**: handleCatchClause
```kotlin
private fun handleCatchClause(catchClause: CatchClause): CatchClause {
    // 创建 catch 子句节点
    val catchClauseDecl = newCatchClause(rawNode = catchClause)

    frontend.scopeManager.enterScope(catchClauseDecl)

    // 处理异常参数
    var possible: Type? = null
    for (type in catchClause.parameter.type.asUnionType().elements) {
        val t = frontend.typeOf(type)
        possible = if (possible == null) t else possible.combineTypes(t)
    }

    val parameter =
        newParameterDeclaration(
            catchClause.parameter.nameAsString,
            possible ?: unknownType(),
            false,
            rawNode = catchClause.parameter,
        )

    frontend.scopeManager.addDeclaration(parameter)
    catchClauseDecl.parameter = parameter

    // 处理 catch 块
    catchClauseDecl.body = handleBlockStatement(catchClause.body)

    frontend.scopeManager.leaveScope(catchClauseDecl)

    return catchClauseDecl
}
```

**解释**：
- 支持 try-with-resources（Java 7+）
- 支持 multi-catch（`catch (IOException | SQLException e)`）
- 对 multi-catch 使用 `combineTypes()` 创建联合类型

---

## 8. 表达式处理示例

### 8.1 方法调用表达式

**文件**: `cpg-language-java/src/main/kotlin/de/fraunhofer/aisec/cpg/frontends/java/ExpressionHandler.kt`

**第 453-542 行**: handleMethodCallExpression
```kotlin
private fun handleMethodCallExpression(expr: Expression): CallExpression {
    val methodCallExpr = expr.asMethodCallExpr()
    val callExpression: CallExpression

    // 获取作用域（base）
    val o = methodCallExpr.scope

    // 获取方法全限定名
    val qualifiedName = frontend.getQualifiedMethodNameAsGoodAsPossible(methodCallExpr)
    var name = qualifiedName
    if (name.contains(".")) {
        name = name.substring(name.lastIndexOf('.') + 1)
    }

    var typeString: String? = null
    var isStatic = false
    var resolved: ResolvedMethodDeclaration? = null

    // 尝试解析方法签名
    try {
        resolved = methodCallExpr.resolve()
        isStatic = resolved.isStatic
        typeString = resolved.returnType.describe()
    } catch (ignored: NoClassDefFoundError) {
        log.debug("Could not resolve method {}", methodCallExpr)
    } catch (ignored: RuntimeException) {
        log.debug("Could not resolve method {}", methodCallExpr)
    }

    // 检查是否是静态导入
    if (frontend.getQualifiedNameFromImports(qualifiedName) != null) {
        isStatic = true
    }

    // 处理 base（调用对象）
    val base: de.fraunhofer.aisec.cpg.graph.statements.expressions.Expression
    if (o.isPresent) {
        // 显式的 base，如 obj.method()
        val scope = o.get()
        base =
            handle(scope) as de.fraunhofer.aisec.cpg.graph.statements.expressions.Expression?
                ?: newProblemExpression("Could not parse base")

        // 如果 base 是类名引用，说明是静态调用
        if (base is Reference && base.refersTo is RecordDeclaration) {
            isStatic = true
        }
    } else {
        // 没有显式 base
        if (isStatic) {
            // 静态调用，创建类名引用作为 base
            val baseType: Type
            val baseName =
                if (resolved != null) {
                    this.parseName(resolved.declaringType().qualifiedName)
                } else {
                    this.parseName(qualifiedName).parent
                }
            baseType = this.objectType(baseName ?: Type.UNKNOWN_TYPE_STRING)
            base = newReference(baseName, baseType)
        } else {
            // 实例方法，创建隐式 this
            base = createImplicitThis()
        }
    }

    // 创建 MemberExpression（base.member）
    val member =
        newMemberExpression(name, base, unknownType(), ".", rawNode = methodCallExpr.name)

    // 创建 MemberCallExpression
    callExpression = newMemberCallExpression(member, isStatic, rawNode = expr)

    // 设置返回类型
    callExpression.type = typeString?.let { this.objectType(it) } ?: unknownType()

    // 处理参数
    val arguments = methodCallExpr.arguments
    for (i in arguments.indices) {
        val argument =
            handle(arguments[i])
                as de.fraunhofer.aisec.cpg.graph.statements.expressions.Expression?

        argument?.argumentIndex = i
        callExpression.addArgument(
            argument ?: newProblemExpression("Could not parse the argument")
        )
    }

    return callExpression
}
```

**示例1**: `obj.method(arg1, arg2)`
- `scope` 存在，解析为 `obj` 的引用
- 创建 `MemberExpression(name="method", base=obj)`
- 创建 `MemberCallExpression` 包含两个参数

**示例2**: `method(arg)` （实例方法）
- `scope` 不存在，`isStatic = false`
- 创建隐式 `this` 作为 base
- 创建 `MemberExpression(name="method", base=this)`

**示例3**: `ClassName.staticMethod(arg)` （静态方法）
- 解析失败或通过静态导入识别为静态
- 创建类名引用作为 base
- 创建 `MemberExpression(name="staticMethod", base=ClassName)`

### 8.2 对象创建表达式

**第 557-628 行**: handleObjectCreationExpr
```kotlin
private fun handleObjectCreationExpr(expr: Expression): NewExpression {
    val objectCreationExpr = expr.asObjectCreationExpr()

    // 解析类型
    val t = frontend.getTypeAsGoodAsPossible(objectCreationExpr.type)
    val constructorName = t.name.localName

    // 创建 NewExpression
    val newExpression = newNewExpression(t, rawNode = expr)

    // 创建 ConstructExpression
    val ctor = newConstructExpression(rawNode = expr)
    ctor.type = t

    // 处理构造函数参数
    val arguments = objectCreationExpr.arguments
    for (i in arguments.indices) {
        val argument =
            handle(arguments[i])
                as? de.fraunhofer.aisec.cpg.graph.statements.expressions.Expression ?: continue

        argument.argumentIndex = i
        ctor.addArgument(argument)
    }

    newExpression.initializer = ctor

    // 处理匿名类
    if (objectCreationExpr.anonymousClassBody.isPresent) {
        // 生成匿名类名（使用位置哈希）
        val locationHash = frontend.locationOf(objectCreationExpr)?.hashCode()
        val anonymousClassName = "$constructorName$locationHash"

        // 创建匿名类记录
        val anonymousRecord = newRecordDeclaration(anonymousClassName, "class")
        anonymousRecord.isImplicit = true

        frontend.scopeManager.enterScope(anonymousRecord)

        // 设置父类
        anonymousRecord.addSuperClass(objectType(constructorName))

        // 处理匿名类体
        val anonymousClassBody = objectCreationExpr.anonymousClassBody.get()
        for (classBody in anonymousClassBody) {
            val classBodyDecl = frontend.declarationHandler.handle(classBody)
            classBodyDecl?.let { anonymousRecord.addDeclaration(it) }
        }

        // 如果没有显式构造函数，创建默认构造函数
        if (anonymousRecord.constructors.isEmpty()) {
            val constructorDeclaration =
                newConstructorDeclaration(anonymousRecord.name.localName, anonymousRecord)
                    .implicit(anonymousRecord.name.localName)

            // 参数与外部构造调用匹配
            ctor.arguments.forEachIndexed { i, arg ->
                constructorDeclaration.parameters +=
                    newParameterDeclaration("arg${i}", arg.type)
            }

            frontend.scopeManager.addDeclaration(constructorDeclaration)
            anonymousRecord.constructors += constructorDeclaration

            // 关联匿名类
            ctor.anonymousClass = anonymousRecord

            frontend.scopeManager.leaveScope(anonymousRecord)
        }
    }

    return newExpression
}
```

**示例**: `new Runnable() { public void run() { ... } }`

处理流程：
1. 类型为 `Runnable`
2. 创建 `NewExpression(Runnable)`
3. 创建 `ConstructExpression`
4. 检测到匿名类体
5. 生成匿名类名：`Runnable<hashCode>`
6. 创建 `RecordDeclaration` 表示匿名类
7. 设置父类为 `Runnable`
8. 处理匿名类的 `run()` 方法
9. 创建默认构造函数
10. 关联匿名类到构造表达式

### 8.3 Lambda 表达式处理

**第 429-451 行**: handleLambdaExpr
```kotlin
private fun handleLambdaExpr(expr: Expression): LambdaExpression {
    val lambdaExpr = expr.asLambdaExpr()

    // 创建 LambdaExpression
    val lambda = newLambdaExpression(rawNode = expr)

    // 进入 lambda 作用域
    frontend.scopeManager.enterScope(lambda)

    // 处理参数
    for (parameter in lambdaExpr.parameters) {
        val param =
            newParameterDeclaration(
                parameter.nameAsString,
                unknownType(),  // Lambda 参数类型通常需要推断
                false,
                rawNode = parameter,
            )
        frontend.scopeManager.addDeclaration(param)
        lambda.parameters += param
    }

    // 处理 lambda 体
    lambda.function =
        if (lambdaExpr.body.isExpressionBody) {
            // 表达式体：x -> x + 1
            frontend.expressionHandler.handle(lambdaExpr.body.asExpressionBody())
        } else {
            // 块体：x -> { return x + 1; }
            frontend.statementHandler.handle(lambdaExpr.body.asBlockStmt())
        }

    frontend.scopeManager.leaveScope(lambda)

    return lambda
}
```

---

## 9. Java 特定 Pass 的实现

### 9.1 JavaImportResolver Pass

**文件**: `cpg-language-java/src/main/kotlin/de/fraunhofer/aisec/cpg/passes/JavaImportResolver.kt`

**第 46-47 行**: Pass 配置
```kotlin
@DependsOn(TypeHierarchyResolver::class)
@RequiredFrontend(JavaLanguageFrontend::class)
```

**第 57-67 行**: accept 方法（主入口）
```kotlin
override fun accept(component: Component) {
    // 第一遍：查找所有可导入的声明
    for (tu in component.translationUnits) {
        findImportables(tu)
    }

    // 第二遍：解析每个类的 import 语句
    for (recordDecl in records) {
        val imports = getDeclarationsForTypeNames(recordDecl.importStatements)
        recordDecl.imports = imports

        val staticImports = getStaticImports(recordDecl)
        recordDecl.staticImports = staticImports
    }
}
```

**第 110-129 行**: findImportables（查找可导入声明）
```kotlin
private fun findImportables(root: Node) {
    // 遍历所有声明节点
    for (declaration in root.declarations) {
        when (declaration) {
            is RecordDeclaration -> {
                // 记录类和接口
                importables[declaration.name.toString()] = declaration
                records += declaration

                // 递归处理嵌套类
                findImportables(declaration)
            }
            is NamespaceDeclaration -> {
                // 递归处理命名空间
                findImportables(declaration)
            }
        }
    }
}
```

**第 69-108 行**: getStaticImports（解析静态导入）
```kotlin
protected fun getStaticImports(
    recordDeclaration: RecordDeclaration
): MutableSet<ValueDeclaration> {
    // 按是否有通配符分组
    val partitioned =
        recordDeclaration.staticImportStatements.groupBy { it.endsWith("*") }.toMutableMap()

    val staticImports = mutableSetOf<ValueDeclaration>()
    val importPattern = Pattern.compile("(?<base>.*)\\.(?<member>.*)")

    // 处理具体的静态导入（import static pkg.Class.member）
    for (specificStaticImport in partitioned[false] ?: listOf()) {
        val matcher = importPattern.matcher(specificStaticImport)
        if (!matcher.matches()) continue

        val base = importables[matcher.group("base")]
        var members = setOf<ValueDeclaration>()

        if (base is RecordDeclaration) {
            // 查找指定的成员
            members = getOrCreateMembers(base, matcher.group("member"))
        }

        staticImports.addAll(members)
    }

    // 处理通配符静态导入（import static pkg.Class.*）
    for (asteriskImport in partitioned[true] ?: listOf()) {
        val base = importables[asteriskImport.replace(".*", "")]

        if (base is EnumDeclaration) {
            // 导入所有枚举常量
            staticImports.addAll(base.entries)
        } else if (base is RecordDeclaration) {
            val classes = listOf(base, *base.superTypeDeclarations.toTypedArray())

            // 导入所有静态方法
            staticImports.addAll(classes.flatMap { it.methods }.filter(MethodDeclaration::isStatic))

            // 导入所有静态字段
            staticImports.addAll(classes.flatMap { it.fields }.filter { "static" in it.modifiers })
        }
    }

    return staticImports
}
```

### 9.2 JavaExternalTypeHierarchyResolver Pass

**文件**: `cpg-language-java/src/main/kotlin/de/fraunhofer/aisec/cpg/passes/JavaExternalTypeHierarchyResolver.kt`

**第 45-47 行**: Pass 配置
```kotlin
@DependsOn(TypeHierarchyResolver::class)
@ExecuteBefore(JavaImportResolver::class)
@RequiredFrontend(JavaLanguageFrontend::class)
```

**第 49-97 行**: accept 方法
```kotlin
override fun accept(component: Component) {
    // 创建 Provider 接口实现
    val provider = object : ContextProvider, LanguageProvider, ScopeProvider {
        override val ctx: TranslationContext = this@JavaExternalTypeHierarchyResolver.ctx
        override val language: Language<*> = JavaLanguage()
        override val scope: Scope? = null
    }

    // 创建组合类型解析器
    val resolver = CombinedTypeSolver()

    // 添加反射解析器（用于 JDK 类）
    resolver.add(ReflectionTypeSolver())

    // 添加源文件解析器
    var root = ctx.currentComponent?.topLevel()
    if (root == null && config.softwareComponents.size == 1) {
        root = config.softwareComponents[config.softwareComponents.keys.first()]?.let {
            CommonPath.commonPath(it)
        }
    }

    if (root != null) {
        log.info("Source file root used for type solver: {}", root)
        resolver.add(JavaParserTypeSolver(root))
    }

    // 遍历所有已知类型
    var types = typeManager.resolvedTypes.toList()
    for (t in types) {
        // 尝试解析类型
        val symbol = resolver.tryToSolveType(t.typeName)

        if (symbol.isSolved) {
            // 获取所有祖先类型
            val resolvedSuperTypes = symbol.correspondingDeclaration.getAncestors(true)

            for (anc in resolvedSuperTypes) {
                // 查找或创建父类型
                var superType = typeManager.lookupResolvedType(anc.qualifiedName)

                if (superType == null) {
                    // 创建新的类型
                    superType = provider.objectType(anc.qualifiedName)
                    superType.typeOrigin = Type.Origin.RESOLVED
                }

                // 添加到类型的 superTypes 列表
                t.superTypes.add(superType)
            }
        }
    }
}
```

**解释**：
- 使用 JavaParser 的类型解析器解析外部类型
- 对项目中引用的每个类型，查找其所有祖先（父类和接口）
- 填充 `Type.superTypes` 列表
- 支持解析 JDK 类（通过 `ReflectionTypeSolver`）

### 9.3 JavaExtraPass

**文件**: `cpg-language-java/src/main/kotlin/de/fraunhofer/aisec/cpg/passes/JavaExtraPass.kt`

**第 50-51 行**: Pass 配置
```kotlin
@DependsOn(TypeResolver::class)
@ExecuteBefore(SymbolResolver::class)
```

**第 55-88 行**: 处理静态字段访问
```kotlin
override fun accept(tu: TranslationUnitDeclaration) {
    // 创建 walker 遍历 AST
    walker = SubgraphWalker.ScopedWalker(ctx.scopeManager, Strategy::AST_FORWARD)

    // 注册 MemberExpression 处理器
    walker.registerHandler { node ->
        when (node) {
            is MemberExpression -> handleMemberExpression(node)
        }
    }

    walker.iterate(tu)
}

fun handleMemberExpression(me: MemberExpression) {
    val parent = me.astParent

    // 只处理字段访问，不处理方法调用
    if (parent is CallExpression && parent.callee == me) return

    // 检查 base 是否是类型引用
    var base = me.base as? Reference
    var type = base?.nameIsType()

    if (type != null) {
        // base 是类型，说明是静态字段访问
        // 将 ClassName.staticField 从 MemberExpression 转换为 Reference

        val ref =
            newReference(type.name.fqn(me.name.localName), type = me.type)
                .codeAndLocationFrom(me)
                .apply { isStaticAccess = true }

        ref.language = me.language

        // 替换节点
        walker.replace(parent, me, ref)
    }
}
```

**示例**：
- **转换前**: `MemberExpression(base=Reference("MyClass"), name="CONSTANT")`
- **转换后**: `Reference("MyClass.CONSTANT", isStaticAccess=true)`

**原因**：
- CPG 中静态成员访问建模为全限定名引用，而不是成员表达式
- 这样更容易进行符号解析和数据流分析

---

## 10. 完整示例追踪

让我们通过一个完整的 Java 示例追踪整个 CPG 生成流程。

### 10.1 示例代码

```java
package com.example;

public class Calculator {
    private int result;

    public Calculator() {
        this.result = 0;
    }

    public int add(int a, int b) {
        result = a + b;
        return result;
    }

    public static void main(String[] args) {
        Calculator calc = new Calculator();
        int sum = calc.add(5, 10);
        System.out.println(sum);
    }
}
```

### 10.2 解析流程追踪

#### 步骤 1: 解析和初始化

**JavaLanguageFrontend.parse()** (114-119 行):
```kotlin
val parser = JavaParser(parserConfiguration)
context = parse(file, parser)  // 返回 CompilationUnit
val tud = newTranslationUnitDeclaration(file.toString(), rawNode = context)
```

**CPG 结构**：
```
TranslationUnitDeclaration("Calculator.java")
```

#### 步骤 2: 包处理

**JavaLanguageFrontend.parse()** (125-141 行):
```kotlin
val packDecl = context?.packageDeclaration  // "com.example"
val holder = ... // 创建嵌套命名空间
```

**CPG 结构**：
```
TranslationUnitDeclaration("Calculator.java")
└── NamespaceDeclaration("com")
    └── NamespaceDeclaration("com.example")
```

#### 步骤 3: 类声明

**DeclarationHandler.handleClassOrInterfaceDeclaration()** (173-212 行):
```kotlin
val recordDeclaration = newRecordDeclaration("com.example.Calculator", "class", ...)
```

**CPG 结构**：
```
TranslationUnitDeclaration("Calculator.java")
└── NamespaceDeclaration("com.example")
    └── RecordDeclaration("com.example.Calculator")
```

#### 步骤 4: 字段声明

**DeclarationHandler.handleFieldDeclaration()** (233-294 行):
```kotlin
// 处理 "private int result;"
val fieldDeclaration = newFieldDeclaration(
    "result",
    IntegerType("int", 32, ...),
    ["private"],
    null,  // 没有初始化器
    ...
)
```

**CPG 结构**：
```
RecordDeclaration("Calculator")
├── FieldDeclaration("result", type=int, modifiers=["private"])
```

#### 步骤 5: 构造函数

**DeclarationHandler.handleConstructorDeclaration()** (296-326 行):
```kotlin
val declaration = newConstructorDeclaration("Calculator", currentRecordDecl, ...)
createMethodReceiver(currentRecordDecl, declaration)  // 创建 this
declaration.body = statementHandler.handle(constructorDecl.body)
```

**处理构造函数体** (StatementHandler.handleBlockStatement):
```kotlin
// this.result = 0;
val assignment = handleAssignmentExpression(...)
```

**CPG 结构**：
```
RecordDeclaration("Calculator")
├── FieldDeclaration("result")
└── ConstructorDeclaration("Calculator")
    ├── ParameterDeclaration("this", type=Calculator) [implicit]
    └── Body: Block
        └── AssignmentExpression
            ├── LHS: MemberExpression(base=Reference("this"), name="result")
            └── RHS: Literal(0)
```

#### 步骤 6: add() 方法

**DeclarationHandler.handleMethodDeclaration()** (105-158 行):
```kotlin
val functionDeclaration = newMethodDeclaration("add", false, currentRecordDecl, ...)
createMethodReceiver(currentRecordDecl, functionDeclaration)

// 处理参数 a
val param1 = newParameterDeclaration("a", IntegerType("int", 32, ...), false, ...)
functionDeclaration.parameters += param1

// 处理参数 b
val param2 = newParameterDeclaration("b", IntegerType("int", 32, ...), false, ...)
functionDeclaration.parameters += param2

// 返回类型
functionDeclaration.returnTypes = [IntegerType("int", ...)]

// 处理方法体
functionDeclaration.body = statementHandler.handle(body)
```

**方法体第一行: result = a + b**

**StatementHandler.handleExpressionStatement()** (608-610 行):
```kotlin
val expression = frontend.expressionHandler.handle(stmt.asExpressionStmt().expression)
return newExpressionStatement(expression, rawNode = stmt)
```

**ExpressionHandler.handleAssignmentExpression()** (82-120 行):
```kotlin
val assignment = newAssignExpression("=", ..., rawNode = expr)

// LHS: result
assignment.lhs += handle(assignExpr.target)  // Reference("result")

// RHS: a + b
assignment.rhs += handle(assignExpr.value)   // BinaryOperator("+", ...)
```

**ExpressionHandler.handleBinaryExpression()** (189-243 行):
```kotlin
val binaryOperator = newBinaryOperator("+", rawNode = expr)
binaryOperator.lhs = handle(binaryExpr.left)   // Reference("a")
binaryOperator.rhs = handle(binaryExpr.right)  // Reference("b")
```

**方法体第二行: return result**

**StatementHandler.handleReturnStatement()** (265-270 行):
```kotlin
val returnStatement = newReturnStatement(rawNode = stmt)
returnStmt.expression.ifPresent {
    returnStatement.returnValue = frontend.expressionHandler.handle(it)
}
```

**CPG 结构**：
```
MethodDeclaration("add")
├── ParameterDeclaration("this", type=Calculator) [implicit]
├── ParameterDeclaration("a", type=int)
├── ParameterDeclaration("b", type=int)
├── ReturnTypes: [int]
└── Body: Block
    ├── AssignmentExpression("=")
    │   ├── LHS: Reference("result")
    │   └── RHS: BinaryOperator("+")
    │       ├── LHS: Reference("a")
    │       └── RHS: Reference("b")
    └── ReturnStatement
        └── ReturnValue: Reference("result")
```

#### 步骤 7: main() 方法

**第一行: Calculator calc = new Calculator();**

**ExpressionHandler.handleObjectCreationExpr()** (557-628 行):
```kotlin
val t = objectType("com.example.Calculator")
val newExpression = newNewExpression(t, ...)
val ctor = newConstructExpression(...)
newExpression.initializer = ctor
```

**DeclarationHandler 处理变量声明** (491-515 行):
```kotlin
val variableDeclaration = newVariableDeclaration(
    "calc",
    objectType("com.example.Calculator"),
    false,
    ...
)
variableDeclaration.initializer = newExpression
```

**第二行: int sum = calc.add(5, 10);**

**ExpressionHandler.handleMethodCallExpression()** (453-542 行):
```kotlin
// base: calc
val base = handle(methodCallExpr.scope.get())  // Reference("calc")

// member: add
val member = newMemberExpression("add", base, ...)

// call
val callExpression = newMemberCallExpression(member, false, ...)

// 参数: 5, 10
callExpression.addArgument(Literal(5))
callExpression.addArgument(Literal(10))
```

**第三行: System.out.println(sum);**

**ExpressionHandler.handleFieldAccessExpression()** (395-416 行):
```kotlin
// System.out
val base = handle(fieldAccessExpr.scope)  // Reference("System")
val member = newMemberExpression("out", base, ...)
```

**ExpressionHandler.handleMethodCallExpression()**:
```kotlin
// println 调用
val base = member  // System.out
val member2 = newMemberExpression("println", base, ...)
val callExpression = newMemberCallExpression(member2, ...)
callExpression.addArgument(Reference("sum"))
```

**完整 CPG 结构**：
```
RecordDeclaration("com.example.Calculator")
├── FieldDeclaration("result", type=int, modifiers=["private"])
├── ConstructorDeclaration("Calculator")
│   └── Body: ...
├── MethodDeclaration("add", modifiers=["public"])
│   ├── Parameters: [this, a, b]
│   └── Body: ...
└── MethodDeclaration("main", modifiers=["public", "static"])
    ├── Parameters: [args]
    └── Body: Block
        ├── DeclarationStatement
        │   └── VariableDeclaration("calc", type=Calculator)
        │       └── Initializer: NewExpression(Calculator)
        │           └── ConstructExpression()
        ├── DeclarationStatement
        │   └── VariableDeclaration("sum", type=int)
        │       └── Initializer: MemberCallExpression
        │           ├── Callee: MemberExpression("add")
        │           │   └── Base: Reference("calc")
        │           └── Arguments: [Literal(5), Literal(10)]
        └── ExpressionStatement
            └── MemberCallExpression
                ├── Callee: MemberExpression("println")
                │   └── Base: MemberExpression("out")
                │       └── Base: Reference("System")
                └── Arguments: [Reference("sum")]
```

#### 步骤 8: Pass 处理

**JavaImportResolver** (57-67 行):
- 解析 `System` 引用到 `java.lang.System`
- 没有显式 import，使用 `java.lang.*` 隐式导入

**JavaExternalTypeHierarchyResolver** (49-97 行):
- 解析 `Calculator` 的父类（隐式继承 `java.lang.Object`）
- 添加 `Object` 到 `Calculator.superTypes`

**JavaExtraPass** (55-88 行):
- 没有静态字段访问，无需转换

**通用 Passes** (cpg-core 提供):

1. **TypeResolver**:
   - 解析 `calc.add(5, 10)` 的返回类型为 `int`
   - 解析 `new Calculator()` 的类型为 `Calculator`

2. **SymbolResolver**:
   - 连接 `Reference("calc")` 到 `VariableDeclaration("calc")`
   - 连接 `Reference("sum")` 到 `VariableDeclaration("sum")`
   - 连接 `Reference("result")` 到 `FieldDeclaration("result")`
   - 连接 `Reference("a")` 到 `ParameterDeclaration("a")`
   - 连接 `Reference("b")` 到 `ParameterDeclaration("b")`

3. **CallResolver**:
   - 解析 `calc.add(5, 10)` 到 `MethodDeclaration("add")`
   - 解析 `new Calculator()` 到 `ConstructorDeclaration("Calculator")`
   - 解析 `System.out.println(sum)` 到 JDK 的 `PrintStream.println(int)`

4. **DFG Builder**:
   - 数据流: `Literal(5)` -> `ParameterDeclaration("a")` -> `BinaryOperator("+")`
   - 数据流: `Literal(10)` -> `ParameterDeclaration("b")` -> `BinaryOperator("+")`
   - 数据流: `BinaryOperator("+")` -> `Reference("result")` -> `FieldDeclaration("result")`
   - 数据流: `Reference("result")` -> `ReturnStatement`
   - 数据流: `MemberCallExpression(add)` -> `VariableDeclaration("sum")`
   - 数据流: `Reference("sum")` -> `MemberCallExpression(println)`

5. **EOG Builder**:
   - 执行顺序: 变量声明 -> 对象创建 -> 赋值 -> 方法调用 -> 变量声明 -> 方法调用 -> println 调用

#### 步骤 9: 最终 CPG

最终的 CPG 包含：
- **节点**: 类声明、方法声明、字段声明、变量声明、表达式、语句等
- **AST 边**: 父子关系（通过 `addDeclaration()`, `body` 等建立）
- **DFG 边**: 数据流关系（通过 DFG pass 建立）
- **EOG 边**: 执行顺序关系（通过 EOG pass 建立）
- **符号引用**: 引用和声明的链接（通过 SymbolResolver 建立）
- **类型信息**: 每个节点的类型（通过 TypeResolver 确定）
- **调用图**: 方法调用和声明的链接（通过 CallResolver 建立）

---

## 总结

本文档详细追踪了 Java 前端的实现，从入口点到各个 Handler 的处理逻辑，再到 Pass 的执行。所有代码引用都包含准确的文件路径和行号，便于读者深入源码学习。

**关键实现模式**：
1. **Visitor 模式**: Handler 使用 map 分发不同 AST 节点类型到对应处理方法
2. **Builder 模式**: 使用 `newXXX()` 工厂方法创建 CPG 节点
3. **作用域栈**: ScopeManager 维护嵌套作用域，支持声明的正确解析
4. **多阶段处理**: 基础 CPG 构建 + 多个 Pass 逐步丰富语义
5. **宽容式处理**: 解析失败时创建 Problem 节点，继续处理其他部分
6. **类型解析**: 结合 JavaParser 的符号解析器和 CPG 的类型系统

通过这些设计，Java 前端实现了准确、完整的 Java 语言支持。
