Role and goal

- Role: Senior static analysis engineer specializing in code property graphs, program analysis, and data flow analysis, producing detailed technical analysis and implementation roadmap in Chinese.
- Goal: Analyze the CPG core's graph structure and query engine to determine feasibility of constant evaluation with branch pruning for reachability analysis, providing evidence-based conclusions with concrete implementation paths.

What to analyze, with evidence

- Graph structure and node model: Identify the CPG graph's core node hierarchy, edge types (AST, EOG, DFG, CDG, PDG), and their semantics; locate Node.kt and related base classes; quote code showing node properties and edge representations.
- Evaluation infrastructure: Analyze the existing ValueEvaluator, MultiValueEvaluator, and SizeEvaluator; understand how constants and expressions are evaluated; document limitations and capabilities with code evidence.
- Control flow and data flow: Study EOG (Evaluation Order Graph) construction for if-else branches, DFG (Data Flow Graph) for constant propagation; identify branching nodes (IfStatement, ConditionalExpression, SwitchStatement) and their handling.
- Query engine capabilities: Examine the Query API in /docs/docs/GettingStarted/query.md and cpg-analysis module; understand executionPath, dataFlow, and existing path analysis mechanisms; assess extensibility for branch-aware queries.
- Constant propagation and reachability: Determine if the current passes support constant propagation; analyze if EOG/DFG can be enhanced to prune unreachable branches based on evaluated conditions; identify missing components.
- Inference and symbolic evaluation: Review the inference system in /docs/docs/CPG/specs/inference.md; check if symbolic values or constraint-based reasoning exists; assess potential for integrating constant folding into branch decisions.

Authoritative references to consult and cite in outputs

- CPG graph model specification (/docs/docs/CPG/specs/graph.md) for node and edge definitions
- EOG specification (/docs/docs/CPG/specs/eog.md) for control flow semantics and branching constructs
- DFG specification (/docs/docs/CPG/specs/dfg.md) for data flow edges and constant propagation patterns
- Query API documentation (/docs/docs/GettingStarted/query.md) for existing analysis capabilities
- Inference specification (/docs/docs/CPG/specs/inference.md) for type and value inference mechanisms
- PDG specification (/docs/docs/CPG/specs/pdg.md) for control and data dependence relationships
- Passes documentation (/docs/docs/CPG/impl/passes.md) for pass orchestration and dependencies

Step-by-step tasks

1) Map the CPG core graph infrastructure

- Locate and read cpg-core/src/main/kotlin/de/fraunhofer/aisec/cpg/graph/Node.kt to understand the base node model and its properties (e.g., prevEOG, nextEOG, prevDFG, nextDFG)
- Identify key edge types: AST edges, EOG (Evaluation Order), DFG (Data Flow), CDG (Control Dependence), PDG (Program Dependence), and their representations in code
- Document the node hierarchy for expressions (Expression, Literal, BinaryOperator, CallExpression, etc.) and statements (IfStatement, WhileStatement, ForStatement, etc.) with file paths and line numbers
- Verify how branching nodes (IfStatement, ConditionalExpression, SwitchStatement) store condition expressions and branch targets in the graph

2) Analyze existing evaluation infrastructure

- Read cpg-core/src/main/kotlin/de/fraunhofer/aisec/cpg/evaluation/ValueEvaluator.kt and related evaluators (MultiValueEvaluator, SizeEvaluator)
- Document what types of expressions can be evaluated to constants (Literal, BinaryOperator with constant operands, etc.) and what cannot (e.g., calls to unknown functions, unresolved references)
- Identify the evaluate() function signature, return types (Any?, or custom value types), and error handling mechanisms
- Check if evaluators support symbolic values, ranges, or constraints, or only concrete values; quote evidence from code
- Examine graph/EvaluationExtensions.kt for utility functions used in queries (min, max, sizeof, etc.)

3) Study control flow and data flow graph construction

- Read the EOG specification at /docs/docs/CPG/specs/eog.md with focus on IfStatement, ConditionalExpression, WhileStatement, ForStatement sections
- Trace how EOG edges are labeled with conditions (e.g., EOG:true, EOG:false) for branches; find code in cpg-core that constructs these edges
- Read the DFG specification at /docs/docs/CPG/specs/dfg.md; understand how VariableDeclaration initializers and AssignExpression create data flows
- Locate passes that build EOG and DFG (e.g., EvaluationOrderGraphPass, DFGPass, ControlFlowSensitiveDFGPass) in cpg-core/src/main/kotlin/de/fraunhofer/aisec/cpg/passes
- Determine if EOG edges can be dynamically pruned or marked as unreachable based on analysis results

4) Assess the query engine and analysis capabilities

- Read /docs/docs/GettingStarted/query.md to understand executionPath, dataFlow, and their parameters (type: Must vs May, sensitivities, scope: Intraprocedural vs Interprocedural)
- Locate the query engine implementation in cpg-analysis module; identify classes like QueryTree, executionPath, dataFlow
- Check if existing analyses can detect infeasible paths or if they assume all EOG edges are feasible
- Determine if query results can be filtered or enhanced by evaluating branch conditions; assess extensibility

5) Feasibility analysis: constant evaluation with branch pruning

- Determine if a new Pass can be created to:
  a) Traverse the graph and evaluate conditions in IfStatement, WhileStatement, etc.
  b) Use ValueEvaluator to compute constant conditions (true/false)
  c) Mark or remove EOG edges leading to unreachable branches
  d) Propagate constants along DFG to enable further pruning in downstream branches
- Identify challenges:
  - Can evaluators handle all constant expressions (consider operator overloading, custom types)?
  - How to handle side effects in conditions (e.g., a = foo() in if (a > 0))?
  - How to integrate with existing passes without breaking dependencies?
  - Is there a mechanism to mark nodes/edges as "unreachable" or "dead code"?
- Propose an implementation path with specific steps, file changes, and pass dependencies

6) Reachability analysis implementation roadmap

- Design a ConstantPropagationPass that:
  - Runs after DFGPass and ControlFlowSensitiveDFGPass
  - Evaluates condition expressions using ValueEvaluator
  - Marks EOG edges with reachability annotations (e.g., a new property like isReachable: Boolean)
  - Optionally prunes or filters unreachable branches in the graph
- Design a ReachabilityAnalysisPass that:
  - Traverses EOG starting from function entry points
  - Skips edges marked as unreachable
  - Computes reachable node sets and reports dead code
- Document integration points:
  - Where to register the new passes in the pass pipeline
  - How to configure via TranslationConfiguration or InferenceConfiguration
  - How to expose results via the Query API or as node annotations
- Identify testing strategy: sample Java/C++ code with constant conditions, expected graph transformations, assertions on reachability

7) Produce detailed Chinese documentation

- Explain the current graph structure with diagrams and code quotes
- Document the evaluation infrastructure's strengths and limitations
- Present the feasibility analysis with evidence (code snippets, specs, observed behaviors)
- Provide the implementation roadmap with step-by-step actions, file paths, and dependencies
- Include example code showing before/after graph structures for a simple if-else with constant condition
- Flag any blockers, assumptions, or areas requiring further research

Outputs to produce under /claude/result/2

- 2.graph-and-query-analysis.md: Deep dive into CPG graph structure, edge types, node model, and query engine capabilities with extensive code quotes
- 2.evaluation-infrastructure.md: Analysis of ValueEvaluator, MultiValueEvaluator, and related evaluation mechanisms; capabilities and limitations for constant folding
- 2.feasibility-and-roadmap.md: Feasibility assessment for constant evaluation with branch pruning, implementation roadmap, integration strategy, and testing plan
- 2.examples-and-diagrams.md: Concrete examples with Mermaid diagrams showing graph transformations, sample code, and expected analysis results

Suggested Mermaid diagrams to include

- CPG node hierarchy: Node -> Statement -> IfStatement, Expression -> BinaryOperator, etc.
- Edge types and semantics: AST, EOG (with condition labels), DFG, CDG, PDG
- EOG for if-else with constant condition: before and after branch pruning
- Pass pipeline: EvaluationOrderGraphPass -> DFGPass -> ControlFlowSensitiveDFGPass -> (new) ConstantPropagationPass -> (new) ReachabilityAnalysisPass
- Data flow for constant propagation: VariableDeclaration -> DFG -> BinaryOperator -> DFG -> condition -> EOG pruning

Acceptance checklist

- All claims backed by code quotes with file paths and line numbers, or references to official specs
- Diagrams included for graph structures, pass pipelines, and example transformations
- Outputs split across files for clarity; Chinese prose with technical terminology aligned to CPG codebase
- Feasibility analysis is evidence-based, not speculative; identifies concrete blockers if any
- Implementation roadmap is actionable with specific file changes, pass registrations, and testing strategies

Evidence requirements

- For every assertion about graph capabilities, cite Node.kt, edge classes, or spec documents
- For evaluation capabilities, quote ValueEvaluator code and show example evaluated expressions
- For EOG/DFG semantics, reference eog.md and dfg.md specs with exact section titles
- For query engine, cite query.md and implementation classes in cpg-analysis
- If a feature is missing, provide evidence by showing what exists and what would need to be added

Quality bar and writing style

- Beginner-first: explain CPG concepts (nodes, edges, passes) before diving into implementation
- Repair-focused: highlight existing limitations and how the proposed solution addresses them
- Evidence-driven: every design decision must trace back to code or spec evidence
- Actionable: the roadmap should be concrete enough for a developer to start implementing
- Scannable: use headings, lists, tables, code blocks, and diagrams; keep sections focused
