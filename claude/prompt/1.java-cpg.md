Role and goal

- Role: Senior static analysis engineer documenting and validating the Java frontend’s integration with the Code Property Graph, producing beginner-friendly but repair-focused documentation in Chinese.
- Goal: Explain how the existing Java frontend produces and enriches a CPG, and give a concrete, referenced checklist for implementing a new Java frontend in this repo.

What to explain, with evidence

- Frontend architecture: Identify whether the repo uses the Joern architecture (x2cpg base and language-specific frontend), a fork such as javasrc2cpg powered by JavaParser, or the Fraunhofer-AISEC cpg library; locate integration points, CLI entry, and build targets.
- Parsing and AST: Show how Java sources are parsed into ASTs and how nodes and edges map to CPG layers; quote code where METHOD, LOCAL, CONTAINS, and related node types and edge labels are constructed or traversed.
- CPG schema and layers: Connect observed nodes/edges to the CPG spec layers, highlighting the META_DATA node, LANGUAGE field, and overlays; explain how overlays are applied and recorded.
- CLI or programmatic entry: Document CLI flags such as language selection, jdk-path, and output paths if Joern CLI or similar is used, and show how the Java frontend is invoked in the codebase or scripts.
- Build integration: Explain how Maven modules produce the frontend artifacts and how they are staged or packaged for use within the repo’s workflows.

Authoritative references to consult and cite in outputs

- CPG Specification (schema, layers, semantics) and Joern CPG building blocks.
- Joern frontends overview, x2cpg base, and the Java frontend CLI/args; if applicable, the javasrc2cpg repository for implementation details.
- Alternative library path via Fraunhofer-AISEC cpg (passes, Java support, JavaParser usage).

Step-by-step tasks

1) Locate the Java frontend module(s) and entry points

- Map Maven modules and identify the Java frontend module names, packaging, and dependencies; note plugins and profiles that affect build and run.
- Grep for CPG-related symbols (e.g., META_DATA, LANGUAGE, overlay mentions, x2cpg, javasrc2cpg) and list the files with line numbers to form a reading plan.

2) Trace CPG generation flow

- From CLI or main entry, walk the pipeline: source discovery → parsing → AST → CPG node/edge construction → overlays; annotate each hand-off with code quotes, files, and lines.
- Verify whether LANGUAGE is set to the expected value and where overlays are added and persisted into the graph.

3) Validate outputs and artifacts

- Run or simulate the pipeline where possible to capture sample outputs and confirm expected node kinds and edges appear, referencing spec terms; attach snippets or counts as evidence.
- Document the output location, format, and any post-processing that occurs, including where the repo stores generated graphs or artifacts.

4) Guidance to implement a new Java frontend

- Choose a foundation: a) Joern x2cpg + a Java source frontend (e.g., javasrc2cpg), or b) Fraunhofer-AISEC cpg for a library-first integration; justify the choice based on repo conventions and build system.
- Minimum requirements: create META_DATA with LANGUAGE set, emit METHOD/LOCAL and essential edges like CONTAINS, and support overlays for enrichment passes consistent with the spec.
- CLI/args: if integrating with Joern-style tools, expose flags like jdk-path and output to align with existing tooling and developer expectations.
- Testing: include fixtures of Java code patterns and validate node/edge presence via queries; document how to run and interpret results for contributors.

5) Produce beginner-first, repair-focused docs

- Explain concepts in Chinese, but cite English sources; begin with a conceptual overview, then walk through the pipeline with diagrams and code quotes, ending with “how to fix/extend”.
- Include a glossary mapping CPG and frontend terms to concise Chinese explanations used consistently across files.

Outputs to produce under /claude/out/1

- 1.overview-java-frontend.md: High-level narrative with a Mermaid flowchart of the pipeline.
- 1.impl-trace.md: Code-quoted, file-and-line referenced walkthrough of the actual implementation flow.
- 1.new-frontend-guide.md: A practical, referenced checklist and scaffolding suggestions to build a new Java frontend.

Suggested Mermaid diagrams to include

- Pipeline flowchart: Source → AST → CPG layers → Overlays → Outputs.
- Module interaction: Parent POM → Java frontend module → Core module → Artifacts.

Acceptance checklist

- All claims backed by code quotes with file and line numbers and/or observed outputs; spec and frontend docs cited where semantics are asserted.
- Diagrams included; outputs split across files for clarity; Chinese prose with standardized glossary.
