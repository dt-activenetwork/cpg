# Task 7: 编程语言理论与编译器概念学习指南 (PL/Compiler Concepts Onboarding Guide)

## Role and goal

- **Role**: Technical educator and onboarding specialist with expertise in compiler theory and static analysis
- **Goal**: 创建一份**面向普通程序员的概念学习指南**,帮助新开发者快速理解 CPG 项目中涉及的编程语言理论 (PL) 和编译器概念
- **Target Audience**: 具有 2-5 年 Java 开发经验但**缺乏编译器/静态分析背景**的工程师

---

## Problem statement and motivation

### The Core Challenge

**CPG 项目大量使用编程语言理论 (PL) 和编译器概念,对普通程序员构成了显著的学习障碍。**

#### Evidence from Previous Tasks

**Task 1-5 中出现的高频概念**:
- **图表示**: AST, CFG, DFG, EOG, CDG, PDG, Call Graph (7 种图)
- **分析范围**: Intraprocedural, Interprocedural, Whole-program (3 个层次)
- **数据流分析**: Constant Propagation, Reaching Definitions, Points-to, Alias Analysis (10+ 算法)
- **控制流分析**: Dominator, Branch Condition, Unreachable Code (5+ 概念)
- **调用图算法**: CHA, RTA, VTA, k-CFA (4 种算法)
- **类型系统**: Type Inference, Subtyping, Generics, Type Erasure (8+ 概念)
- **CPG 特有**: Handler Pattern, Pass System, Query API, Sensitivity (15+ 概念)

**Total**: 60+ 专业概念,其中 20+ 为核心必备概念。

#### Real-World Pain Points

**从 Task 5 人力资源分析的发现**:
1. **技能缺口大**: 修复 D1-D4 (P0-P1 缺陷) 需要:
   - "深度理解 Java static final 语义" (超出普通 Java 开发者知识)
   - "数据流分析 (DFA) 算法设计经验" (编译器背景)
   - "Call graph construction (CHA/RTA)" (静态分析框架经验)

2. **学习曲线陡峭**: 普通 Java 工程师需要:
   - 学习 **7 种图表示** (AST, CFG, DFG, EOG, CDG, PDG, Call Graph)
   - 理解 **3 层分析范围** (Intraprocedural → Interprocedural → Whole-program)
   - 掌握 **10+ 数据流算法** (Constant Propagation, Reaching Definitions, etc.)

3. **概念循环依赖**: 文档中常见的定义:
   - "DFG 是数据流图" ← 什么是数据流?
   - "EOG 用于构建 CFG" ← EOG 和 CFG 有什么区别?
   - "Interprocedural DFG 基于 Call Graph" ← Call Graph 怎么构建?

4. **缺少学习路径**: 现有文档 (Task 1-5) 是**技术分析文档**,不是**教学材料**:
   - Task 1: 假设读者已理解 "AST transformation", "Handler pattern"
   - Task 2: 直接使用 "EOG", "DFG", "lattice-based analysis" 而不解释
   - Task 4: 讨论 "CHA vs RTA vs k-CFA" 但不说明它们是什么

### The Gap

**现状**: CPG 项目有高质量的技术分析文档 (Task 1-5),但缺少**针对普通程序员的概念入门指南**。

**需要**: 一份结构化的学习材料,帮助普通 Java 工程师在 **2-4 周内**掌握足够的 PL/编译器知识,能够:
- ✅ 阅读 CPG 代码并理解设计意图
- ✅ 修复简单的 P2-P3 缺陷 (如 D15, D16)
- ✅ 与 Senior/Expert 工程师有效沟通
- ✅ 为未来深入学习打下基础

---

## Objectives and deliverables

### Primary Objective

创建一份**渐进式、实例驱动、避免循环定义的概念学习指南**,覆盖 CPG 项目中的 20+ 核心 PL/编译器概念。

### Deliverables

在 `/claude/result/7/` 下生成以下文档:

#### 7.1-索引-学习路线图.md (Learning Roadmap and Index)
**目的**: 提供学习路径导航和快速参考

**内容**:
- **Executive Summary**: 本指南的目标读者、使用方法、预期学习时间
- **学习路径图** (Mermaid diagram):
  - Week 1: 基础概念 (AST, Symbol Resolution, Scope)
  - Week 2: 图表示 (CFG, DFG, EOG) 和过程内分析
  - Week 3: 过程间分析 (Call Graph, Interprocedural DFG)
  - Week 4: CPG 特有概念 (Handler, Pass, Query API)
- **概念目录**: 按字母排序的所有概念索引,包含:
  - 概念名称 (中英文)
  - 难度级别 (Beginner/Intermediate/Advanced)
  - 所在章节
  - 前置依赖
- **学习建议**: 不同背景读者的学习路径建议
  - Java 开发者 (无编译器背景): 推荐路径 A
  - 有 C/C++ 经验的开发者: 推荐路径 B
  - 有编译器课程基础: 推荐路径 C
- **快速查询表**: 概念 → CPG 代码位置的映射

**长度**: ~800-1200 行

---

#### 7.2-基础-图表示与分析.md (Graph Representations and Analysis Foundations)
**目的**: 解释 7 种图表示和 3 种分析范围

**内容**:

**Part 1: 图表示基础 (Graph Representations)**

对每种图,提供:
1. **通俗定义** (Plain Language Definition):
   - 用日常语言解释概念,避免使用其他未定义的术语
   - 例如: "AST 是什么? → 将代码的语法结构转化为树状图,每个节点代表一个语法元素"

2. **为什么需要这个图?** (Motivation):
   - 解决什么问题?
   - 例如: "为什么有了 AST 还需要 CFG? → AST 只展示语法结构,CFG 展示执行顺序,用于分析程序行为"

3. **简单示例** (Simple Example):
   - 5-10 行 Java 代码
   - 手绘该图的示意 (Mermaid diagram)
   - 逐步说明图的构建过程

4. **CPG 中的体现** (CPG Implementation):
   - 在 CPG 代码中的位置 (文件:行号)
   - 关键数据结构 (如 `Node.prevEOGEdges`)
   - 构建该图的 Pass (如 `EvaluationOrderGraphPass`)

5. **与其他图的关系** (Relationship to Other Graphs):
   - 依赖关系 (如 "DFG 依赖 CFG")
   - 互补关系 (如 "CFG 展示控制流, DFG 展示数据流")

6. **常见误解** (Common Misconceptions):
   - 例如: "EOG 不是 CFG! EOG 是语句级别, CFG 是块级别"
   - 例如: "AST 不包含执行顺序信息"

**涵盖的图**:
- AST (Abstract Syntax Tree)
- CFG (Control Flow Graph)
- DFG (Data Flow Graph)
- EOG (Evaluation Order Graph) ← CPG 特有
- CDG (Control Dependence Graph)
- PDG (Program Dependence Graph)
- Call Graph

**Part 2: 分析范围 (Analysis Scopes)**

**2.1 Intraprocedural Analysis (过程内分析)**
- 定义: 只分析单个方法/函数内部
- 优点: 快速、精确 (无跨方法不确定性)
- 局限: 无法追踪跨方法的数据流/控制流
- CPG 示例: `UnreachableEOGPass` (EOG 不跨方法边界)
- 简单示例: 检测方法内的不可达代码

**2.2 Interprocedural Analysis (过程间分析)**
- 定义: 分析跨方法调用的数据流/控制流
- 为什么需要: Task 3 Scenario 2 展示了常量跨方法传递的必要性
- 挑战: 调用图构建、上下文敏感性、性能开销
- CPG 缺陷: D3 (Interprocedural DFG 缺失), D4 (Call Graph 缺失)
- 简单示例: 追踪常量从 main() 传递到 helper()

**2.3 Whole-Program Analysis (全程序分析)**
- 定义: 分析整个程序 (所有类、所有方法)
- 应用: 死代码消除、全局优化、安全漏洞检测
- 挑战: 性能、可扩展性、第三方库处理
- CPG 缺陷: D10 (Bytecode Analysis for Libraries), D11 (Incremental Analysis)

**长度**: ~2000-3000 行

---

#### 7.3-进阶-数据流与控制流分析.md (Data Flow and Control Flow Analysis)
**目的**: 解释 10+ 数据流算法和控制流概念

**内容**:

**Part 1: 数据流分析算法 (Data Flow Analysis Algorithms)**

对每种算法,提供:
1. **问题陈述** (Problem Statement):
   - 这个算法要回答什么问题?
   - 例如: "Constant Propagation 回答: 哪些变量在程序点 P 是常量?"

2. **算法直觉** (Intuition):
   - 用类比解释算法思想
   - 例如: "Reaching Definitions 类似于'快递追踪': 从变量定义点到使用点的所有可能路径"

3. **简化版伪代码** (Simplified Pseudocode):
   - 10-20 行伪代码,展示核心思想
   - 避免复杂的格理论符号

4. **手工示例** (Manual Example):
   - 5-10 行 Java 代码
   - 逐步展示算法如何分析这段代码
   - 展示每个程序点的分析结果

5. **CPG 中的实现** (CPG Implementation):
   - 对应的 CPG Pass 或类 (如 `ValueEvaluator` 实现简化版 Constant Propagation)
   - 代码位置和关键方法

6. **局限性** (Limitations):
   - 这个算法在什么情况下失效?
   - CPG 当前实现的局限 (参考 Task 4 缺陷分析)

**涵盖的算法**:
- Constant Propagation (常量传播) ← CPG 已实现 (简化版)
- Reaching Definitions (到达定值)
- Live Variables (活跃变量)
- Available Expressions (可用表达式)
- Taint Analysis (污点分析)
- Points-to Analysis (指向分析) ← CPG 缺失 (D7)
- Alias Analysis (别名分析) ← CPG 缺失 (D7)

**Part 2: 控制流分析概念 (Control Flow Analysis Concepts)**

- Dominator (支配节点)
- Post-dominator (后支配节点)
- Dominance Frontier (支配边界)
- Loop Detection (循环检测)
- Unreachable Code Detection (不可达代码检测) ← CPG 已实现 (`UnreachableEOGPass`)

**Part 3: Forward vs Backward Analysis**
- 前向分析和后向分析的区别
- 何时使用哪种分析
- CPG 示例: DFGPass (前向), Live Variables (后向, CPG 未实现)

**Part 4: Lattice-based Analysis (格理论分析)**
- 为什么需要格理论?
- 简化版解释 (避免数学符号)
- CPG 示例: `ValueEvaluator` 使用的 lattice (BOTTOM → 常量值 → TOP)

**长度**: ~2500-3500 行

---

#### 7.4-进阶-调用图与过程间分析.md (Call Graph and Interprocedural Analysis)
**目的**: 解释调用图构建算法和过程间分析

**内容**:

**Part 1: 调用图基础 (Call Graph Fundamentals)**

**1.1 什么是调用图?**
- 定义: 节点 = 方法, 边 = 调用关系
- 为什么需要: Interprocedural analysis 的基础
- 简单示例: main() → helper1() → helper2()

**1.2 静态调用图的挑战**
- 动态分派 (Dynamic Dispatch): 接口/抽象类调用
- 反射 (Reflection): `Method.invoke()`
- 函数指针/Lambda: 间接调用
- 第三方库: 无源码

**Part 2: 调用图构建算法 (Call Graph Construction Algorithms)**

对每种算法,提供:
1. **算法原理** (Algorithm Principle)
2. **精度 vs 开销权衡** (Precision vs Cost Trade-off)
3. **手工示例** (5-10 行 Java 代码,展示算法如何处理)
4. **CPG 状态** (CPG 是否实现,参考 Task 4 D4)

**涵盖的算法**:
- **CHA (Class Hierarchy Analysis)** ← Task 4 建议实现
  - 原理: 基于类层次推断可能的调用目标
  - 精度: 低 (over-approximate, 可能包含永远不会调用的方法)
  - 开销: 低 (O(n) 构建时间)
  - 示例: Interface.method() → 所有实现类的 method()

- **RTA (Rapid Type Analysis)**
  - 原理: CHA + 只考虑已实例化的类
  - 精度: 中等
  - 开销: 中等

- **VTA (Variable Type Analysis)**
  - 原理: RTA + 跟踪变量类型
  - 精度: 高
  - 开销: 高

- **k-CFA (k-level Context-Sensitive Analysis)**
  - 原理: 区分不同调用上下文
  - 精度: 非常高
  - 开销: 非常高 (指数级)

**Part 3: Interprocedural Data Flow Analysis (过程间数据流分析)**

**3.1 基本原理**
- Summary-based approach: 为每个方法计算"摘要"
- Inline-based approach: 内联方法调用
- Call-string approach: 跟踪调用路径

**3.2 CPG 缺陷分析**
- Task 4 D3: Interprocedural DFG 缺失
- Task 3 Scenario 2: 展示了需求 (常量跨方法传递)
- 实现建议: Summary-based + CHA call graph

**3.3 上下文敏感性 (Context Sensitivity)**
- 为什么需要: 避免误报
- 示例: 同一个方法被不同上下文调用,参数不同
- CPG Query API 的 `ContextSensitive` sensitivity

**长度**: ~2000-3000 行

---

#### 7.5-CPG专有-架构与Pass系统.md (CPG-Specific: Architecture and Pass System)
**目的**: 解释 CPG 特有的概念和设计模式

**内容**:

**Part 1: CPG 架构概览 (CPG Architecture Overview)**

**1.1 四层架构**
- **Frontend Layer**: 语言特定解析 (Java, Python, C++, etc.)
- **Core Layer**: 图构建、Pass 基础设施、通用数据结构
- **Pass Layer**: Enrichment passes (TypeResolver, DFGPass, UnreachableEOGPass, etc.)
- **Query Layer**: Query API DSL, Sensitivity, executionPath()

**1.2 为什么这样设计?**
- Frontend/Core 分离: 语言无关的核心
- Pass 系统: 模块化、可组合的分析
- Query API: 用户友好的查询接口

**Part 2: Handler Pattern (处理器模式)**

**2.1 问题陈述**
- 如何将语言特定的 AST (如 JavaParser AST) 转换为通用的 CPG 节点?

**2.2 Handler Pattern 解决方案**
- **DeclarationHandler**: 处理类、方法、字段声明
- **StatementHandler**: 处理语句 (if, while, for, etc.)
- **ExpressionHandler**: 处理表达式 (二元运算、方法调用, etc.)

**2.3 代码示例**
- 从 Task 1 提取关键代码片段
- 展示 `handleMethodDeclaration()` 的完整流程

**Part 3: Pass System (Pass 系统)**

**3.1 什么是 Pass?**
- 定义: 遍历 CPG 图并进行分析/转换的模块
- 类比: "装配线上的工作站",每个 Pass 负责一个特定任务

**3.2 Pass 的类型**
- **EOGStarterPass**: 构建 EOG 的 Pass 基类
- **DependsOn**: Pass 依赖关系声明
- **Language-specific Pass**: 如 `JavaExtraPass`, `PythonUnreachableEOGPass`

**3.3 Pass 执行顺序**
- Task 2 分析的依赖链:
  ```
  EvaluationOrderGraphPass → DFGPass → ControlFlowSensitiveDFGPass → UnreachableEOGPass
  ```
- 为什么顺序重要: 后续 Pass 依赖前面 Pass 的结果

**3.4 如何编写自定义 Pass**
- 最小化示例: 统计节点数量的 Pass
- 关键方法: `accept()`, `cleanup()`
- 注册 Pass: 添加到 `PassConfiguration`

**Part 4: Query API DSL**

**4.1 为什么需要 Query API?**
- 问题: 直接遍历图太底层、易错
- 解决方案: 提供声明式 DSL

**4.2 核心概念**
- **QueryTree**: 查询树表示
- **Sensitivity**: 分析敏感性设置
  - `FilterUnreachableEOG`: 自动过滤不可达边
  - `ContextSensitive`: 上下文敏感分析
- **Quantifier**: 量词 (all, exists)

**4.3 示例查询**
- Task 3 Scenario 1: 查询可达的工厂方法
- 从简单查询到复杂查询的渐进示例

**Part 5: CPG vs 其他框架**

**5.1 CPG vs Soot**
- Soot: 基于 Jimple (字节码中间表示)
- CPG: 基于源码 (支持多语言)

**5.2 CPG vs WALA**
- WALA: IBM 的静态分析框架,主要用于 Java 字节码
- CPG: 更现代、更灵活的架构

**5.3 CPG vs Joern**
- Joern: 基于 CPG 的安全分析工具
- Fraunhofer AISEC CPG: 本项目使用的底层库

**长度**: ~2500-3500 行

---

#### 7.6-参考-学习资源与常见问题.md (Learning Resources and FAQ)
**目的**: 提供外部学习资源和常见问题解答

**内容**:

**Part 1: 推荐学习资源 (Recommended Learning Resources)**

**1.1 教材 (Textbooks)**
- **基础**:
  - "Compilers: Principles, Techniques, and Tools" (龙书) - 第 1-6 章 (AST, Symbol Table, Type Checking)
  - "Modern Compiler Implementation in Java" (虎书) - 第 1-10 章
- **进阶**:
  - "Principles of Program Analysis" (Nielson & Nielson) - 数据流分析标准教材
  - "Static Program Analysis" (Anders Møller & Michael I. Schwartzbach) - 免费在线书籍

**1.2 在线课程 (Online Courses)**
- **Coursera**: "Compilers" by Stanford (Alex Aiken)
- **edX**: "Software Analysis & Testing" by Georgia Tech
- **YouTube**: "Static Program Analysis" by Yannis Smaragdakis (Athens)

**1.3 论文 (Research Papers)**
- **Call Graph 算法**:
  - "Fast Static Analysis of C++ Virtual Function Calls" (CHA 原始论文)
  - "Scaling CFL-Reachability-Based Points-To Analysis Using Context-Sensitive Must-Not-Alias Analysis"
- **Data Flow Analysis**:
  - "A Unified Approach to Global Program Optimization" (Kildall 1973) - Lattice 理论基础
  - "Precise Interprocedural Dataflow Analysis via Graph Reachability" (Reps et al.)

**1.4 工具和框架 (Tools and Frameworks)**
- **Soot**: Java 静态分析框架 - 学习参考实现
- **WALA**: IBM 的分析库 - 学习 call graph 构建
- **Joern**: 安全分析工具 - 学习 CPG 应用

**Part 2: 从 CPG 代码学习 (Learning from CPG Code)**

**2.1 推荐阅读顺序**
1. **Week 1**: 读 `Node.kt` (理解图节点结构) + `EvaluationOrder.kt` (理解 EOG 边)
2. **Week 2**: 读 `JavaLanguageFrontend.kt` + `DeclarationHandler.kt` (理解 Frontend 工作原理)
3. **Week 3**: 读 `EvaluationOrderGraphPass.kt` (理解 EOG 构建) + `DFGPass.kt` (理解 DFG 构建)
4. **Week 4**: 读 `UnreachableEOGPass.kt` + `ValueEvaluator.kt` (理解常量求值)

**2.2 调试技巧**
- 如何运行 CPG 并打印图结构
- 如何可视化 CPG (导出 DOT 格式)
- 如何编写单元测试验证理解

**Part 3: 常见问题解答 (FAQ)**

**Q1: AST 和 CFG 有什么区别?**
- A: AST 展示语法结构 (如何写), CFG 展示执行顺序 (如何跑)

**Q2: EOG 和 CFG 有什么区别?**
- A: EOG 是语句级别, CFG 是基本块级别。EOG 更细粒度。

**Q3: DFG 如何处理多个赋值 (phi 节点)?**
- A: CPG 当前不使用 SSA 形式,因此一个变量可以有多个 incoming DFG 边 (merge point)。ValueEvaluator 在这种情况下返回 TOP (未知值)。

**Q4: CPG 支持哪些语言?**
- A: Java, Python, C++, Go, JavaScript, TypeScript, Ruby, LLVM IR 等 (通过不同的 Frontend)

**Q5: 如何为 CPG 添加新语言支持?**
- A: 参考 Task 1 的 `1.3-指南-新前端开发.md`

**Q6: Interprocedural DFG 和 Intraprocedural DFG 的性能差异?**
- A: Interprocedural 通常慢 10-100 倍,取决于 call graph 大小和算法精度。

**Q7: CPG 的 Pass 可以并行执行吗?**
- A: 当前不支持 (Task 4 D8 缺陷),未来可以实现 file-level 和 pass-level 并行化。

**Q8: 如何选择 Call Graph 算法 (CHA vs RTA vs k-CFA)?**
- A: CHA (快速原型), RTA (生产环境平衡), k-CFA (高精度研究)

**Q9: Points-to Analysis 和 Alias Analysis 有什么区别?**
- A: Points-to 回答"指针指向哪个对象", Alias 回答"两个指针是否指向同一对象"。Alias 通常基于 Points-to 实现。

**Q10: CPG 的 Query API 如何自动过滤不可达代码?**
- A: `executionPath()` 默认启用 `FilterUnreachableEOG` sensitivity,跳过 `unreachable == true` 的 EOG 边。

**Part 4: 术语表 (Glossary)**

按字母排序的所有概念中英文对照和简短定义 (1-2 句话)。

**长度**: ~1500-2000 行

---

## Document organization strategy

### Multi-Document Structure

**总计 6 个文档,~12,000-18,000 行**:
1. **7.1-索引-学习路线图.md** (~1000 lines) - 导航和路径规划
2. **7.2-基础-图表示与分析.md** (~2500 lines) - 图基础
3. **7.3-进阶-数据流与控制流分析.md** (~3000 lines) - 分析算法
4. **7.4-进阶-调用图与过程间分析.md** (~2500 lines) - 过程间分析
5. **7.5-CPG专有-架构与Pass系统.md** (~3000 lines) - CPG 特有概念
6. **7.6-参考-学习资源与常见问题.md** (~1500 lines) - 外部资源和 FAQ

### Reading Paths for Different Audiences

**路径 A: Java 开发者 (无编译器背景)**
- Week 1: 7.1 (学习路线) + 7.2 Part 1 (图表示基础,只读 AST/CFG/DFG)
- Week 2: 7.2 Part 2 (分析范围) + 7.3 Part 1 (只读 Constant Propagation, Reaching Definitions)
- Week 3: 7.5 (CPG 架构和 Pass 系统) + 开始读 CPG 代码
- Week 4: 7.4 Part 1-2 (Call Graph 基础) + 7.6 (FAQ 和资源)

**路径 B: 有编译器课程基础**
- Week 1: 7.1 (快速浏览) + 7.2 (快速复习) + 7.5 (重点: CPG 特有概念)
- Week 2: 7.4 (重点: Call Graph 算法) + 7.3 Part 3-4 (Lattice, Forward/Backward)
- Week 3: 读 CPG 代码 (重点: Pass 系统和 Query API)
- Week 4: 实践: 修复简单缺陷 (如 Task 4 D15, D16)

**路径 C: Senior/Expert (只需查缺补漏)**
- 使用 7.1 索引快速定位不熟悉的概念
- 重点阅读 7.5 (CPG 特有概念) 和 7.6 (FAQ)
- 直接阅读 CPG 代码 + 参考本指南查询细节

---

## Key principles for content creation

### Principle 1: Avoid Circular Definitions (避免循环定义)

**❌ Bad Example**:
- "DFG 是数据流图"
- "EOG 用于构建 CFG"

**✅ Good Example**:
- "DFG (Data Flow Graph) 是一种图结构,节点代表程序中的变量/表达式,边代表数据如何从一个变量流向另一个变量。例如,在代码 `int a = 1; int b = a + 2;` 中,有一条边从 `a` 指向 `a + 2`,表示 `a` 的值流向了表达式 `a + 2`。"

### Principle 2: Progressive Disclosure (渐进式披露)

**策略**: 先给简单例子,再给复杂例子,最后给 CPG 代码引用。

**Example**:
1. **Simple**: 5 行 Java 代码 + 手绘图
2. **Intermediate**: 15 行 Java 代码 + 算法步骤
3. **CPG**: CPG 代码片段 + 文件:行号引用

### Principle 3: Use Analogies (使用类比)

**Examples**:
- AST: "像语法树,小学语文课画的句子成分树"
- CFG: "像地铁线路图,展示程序执行的所有可能路径"
- DFG: "像快递追踪,展示数据从哪里来,到哪里去"
- Call Graph: "像公司组织架构图,展示方法调用关系"
- Pass System: "像装配线,每个工作站 (Pass) 负责一个任务"

### Principle 4: Concrete Before Abstract (先具体后抽象)

**❌ Bad Approach**: 先讲 Lattice 理论,再讲 Constant Propagation

**✅ Good Approach**: 先用简单例子展示 Constant Propagation 如何工作,然后说"这背后的数学理论叫 Lattice 理论"

### Principle 5: Link to CPG Code (链接到 CPG 代码)

**每个概念都应提供**:
- CPG 中的实现位置 (文件:行号)
- 对应的 Class/Pass 名称
- 如何在 CPG 代码中找到这个概念的实例

**Example**:
```markdown
**EOG (Evaluation Order Graph)**:
- **CPG 实现**: `Node.kt` 第 110-154 行 定义了 `prevEOGEdges` 和 `nextEOGEdges`
- **构建 Pass**: `EvaluationOrderGraphPass.kt` (cpg-core/src/main/kotlin/.../passes/)
- **查看示例**: 运行 Task 2 的示例代码,打印 EOG 边
```

### Principle 6: Distinguish CPG-Specific from Universal (区分 CPG 特有和通用概念)

**通用概念** (所有静态分析框架都有):
- AST, CFG, DFG, Call Graph, Constant Propagation, Points-to Analysis

**CPG 特有概念**:
- EOG (其他框架用 CFG)
- Handler Pattern (CPG 的 AST 转换模式)
- Pass System (CPG 的模块化设计)
- Query API (CPG 的查询 DSL)

**在文档中明确标注**: `[CPG Specific]` 或 `[Universal Concept]`

---

## Tone and style

### Target Audience Characteristics

**典型读者画像**:
- **背景**: 2-5 年 Java/Python 开发经验
- **教育**: 计算机科学本科 (可能没学过编译原理课)
- **动机**: 加入 CPG 项目,需要快速上手
- **痛点**: 看不懂代码中的 "DFG", "EOG", "intraprocedural" 等术语
- **期望**: 2-4 周内能读懂 CPG 代码,修复简单缺陷

### Writing Style

- **语言**: 中文为主,英文术语保留 (首次出现时给中文翻译)
- **语气**: 友好、耐心、避免"显然"、"容易理解"等假设
- **句式**: 短句为主,避免复杂从句
- **术语**: 首次出现时解释,之后可以直接使用
- **代码**: 优先使用 Java (读者熟悉),Kotlin 代码需要简单注释

### Examples of Good vs Bad Explanations

**❌ Bad** (循环定义, 假设背景知识):
```
DFG 是数据流图,用于表示程序的数据依赖关系。通过 reaching definitions 分析,
我们可以构建 def-use 链,进而实现常量传播优化。
```

**✅ Good** (渐进式, 使用类比):
```
**DFG (Data Flow Graph, 数据流图)** 是一种特殊的图,用来追踪"数据从哪里来,到哪里去"。

**类比**: 想象你在追踪一笔钱的流向:
- 节点 = 账户 (变量/表达式)
- 边 = 转账记录 (数据流动)

**简单示例**:
```java
int a = 5;        // 定义: a = 5
int b = a + 2;    // 使用: a 的值流向 "a + 2"
int c = b * 3;    // 使用: b 的值流向 "b * 3"
```

**DFG 图示**:
```
a (值:5) ---> a+2 (值:7) ---> b (值:7) ---> b*3 (值:21) ---> c (值:21)
```

**CPG 中的体现**:
- `Node.kt` 第 156-200 行定义了 `prevDFGEdges` 和 `nextDFGEdges`
- `DFGPass.kt` 负责构建基础 DFG 边
- 运行 `cpg-analysis` 示例可以看到 DFG 边的实际构建过程
```

---

## Integration with existing documentation

### Cross-References to Task 1-5

**本指南应频繁引用已有文档**:
- Task 1: Java Frontend 架构 → 引用 Handler Pattern, Frontend/Core 分离
- Task 2: EOG/DFG/Pass 详解 → 引用 UnreachableEOGPass, ValueEvaluator
- Task 3: 教学演示 → 引用场景示例作为学习案例
- Task 4: 缺陷分析 → 说明哪些概念缺失 (如 Interprocedural DFG, Call Graph)
- Task 5: 技能需求 → 说明掌握哪些概念对应哪些角色

**Format for Cross-References**:
```markdown
**进一步阅读**: 关于 Handler Pattern 的完整分析,参见:
- Task 1: `/claude/result/1/1.1-概览-Java前端架构.md` (第 3.2 节)
- Semantic note: `sem-002` (handler-pattern.md)
```

### Complementary to Existing Docs

**Task 1-5 是"技术分析文档"**: 假设读者已理解概念,重点分析 CPG 实现细节

**Task 7 是"教学文档"**: 从零开始解释概念,帮助读者达到能阅读 Task 1-5 的水平

**Workflow**:
```
新工程师加入项目
    ↓
先读 Task 7 (2-4 weeks) - 学习 PL/编译器概念
    ↓
再读 Task 1-5 (1-2 weeks) - 理解 CPG 实现细节
    ↓
开始修复缺陷 / 添加功能
```

---

## Quality metrics and acceptance criteria

### Content Completeness

- [x] 覆盖 20+ 核心 PL/编译器概念 (见 Concept Inventory)
- [x] 每个概念都有:
  - 通俗定义 (避免循环定义)
  - 简单示例 (5-10 行代码 + 手绘图)
  - CPG 实现位置 (文件:行号)
  - 常见误解澄清
- [x] 提供 3 条学习路径 (不同背景读者)
- [x] 包含 10+ 外部学习资源引用
- [x] FAQ 回答 10+ 常见问题

### Pedagogical Quality

- [x] 避免循环定义 (每个概念用已知术语解释)
- [x] 渐进式披露 (简单 → 复杂 → CPG 代码)
- [x] 使用类比 (每个抽象概念至少 1 个类比)
- [x] 具体先于抽象 (示例先于理论)
- [x] 频繁使用 Mermaid 图表 (目标: 30+ 图表)

### Practical Utility

- [x] 读者能在 2-4 周内:
  - 阅读 CPG 代码并理解设计意图
  - 修复简单缺陷 (P2-P3, 如 D15, D16)
  - 与 Senior 工程师有效沟通
- [x] 提供可执行的学习路径 (每周具体任务)
- [x] 链接到 CPG 代码位置 (可直接跳转验证)

### Integration with Existing Docs

- [x] 频繁引用 Task 1-5 (每个文档至少 5 处引用)
- [x] 与 Semantic notes (sem-001 to sem-004) 交叉引用
- [x] 明确说明本文档与 Task 1-5 的关系 (教学 vs 技术分析)

---

## Step-by-step execution plan

### Memory-First Approach

**BEFORE starting**:
1. ✅ Read `/claude/memory/index/tags.json` and `topics.json`
2. ✅ Read semantic notes: sem-001, sem-002, sem-003, sem-004
3. ✅ Read episodic notes: ep-001, ep-002, ep-004, ep-007, ep-010
4. ✅ Create concept inventory: `/claude/temp/task-7/brainstorm/PL_CONCEPTS_INVENTORY.md` ← ALREADY CREATED
5. ✅ Read Task 1-5 outputs selectively (use task-3-index.json if available)

### Incremental Document Creation

**Given the large scope (12,000-18,000 lines), use incremental approach**:

#### Step 1: Create index and roadmap (7.1)
- **Context budget**: <2000 lines (read concept inventory + episodic notes)
- **Output**: 7.1-索引-学习路线图.md (~1000 lines)
- **Checkpoint**: Update episodic note with progress

#### Step 2: Create graph foundations (7.2)
- **Context budget**: <2500 lines (read Task 2 outputs for EOG/DFG details)
- **Output**: 7.2-基础-图表示与分析.md (~2500 lines)
- **Checkpoint**: Update episodic note

#### Step 3: Create data flow analysis (7.3)
- **Context budget**: <3000 lines (read Task 2 ValueEvaluator sections)
- **Output**: 7.3-进阶-数据流与控制流分析.md (~3000 lines)
- **Checkpoint**: Update episodic note

#### Step 4: Create call graph and interprocedural (7.4)
- **Context budget**: <2500 lines (read Task 4 D3/D4 sections)
- **Output**: 7.4-进阶-调用图与过程间分析.md (~2500 lines)
- **Checkpoint**: Update episodic note

#### Step 5: Create CPG-specific concepts (7.5)
- **Context budget**: <3000 lines (read Task 1 outputs for Handler/Pass)
- **Output**: 7.5-CPG专有-架构与Pass系统.md (~3000 lines)
- **Checkpoint**: Update episodic note

#### Step 6: Create resources and FAQ (7.6)
- **Context budget**: <1500 lines (aggregate questions from previous steps)
- **Output**: 7.6-参考-学习资源与常见问题.md (~1500 lines)
- **Checkpoint**: Update episodic note

#### Step 7: Final review and cross-linking
- **Context budget**: <1000 lines (skim all 6 documents)
- **Output**: Add cross-references, verify consistency
- **Checkpoint**: Create final episodic note (ep-013)

### Memory Update Strategy

**AFTER task completion**:
1. Create episodic note: `ep-013` (Task 7 execution summary)
2. Create semantic note: `sem-006` (PL/Compiler Concept Taxonomy) - 提取核心概念分类作为可复用知识
3. Update `tags.json`: Add "onboarding", "education", "pl-theory", "compiler-concepts", "task-7"
4. Update `topics.json`: Add "Developer Onboarding" topic

---

## Final notes

### Success Criteria

**This task is successful if**:
1. A new Java developer (2-5 years experience, no compiler background) can:
   - Read and understand CPG code within 2-4 weeks
   - Fix simple P2-P3 defects (like D15, D16)
   - Communicate effectively with Senior/Expert engineers
2. All 20+ core concepts are explained without circular definitions
3. At least 30 Mermaid diagrams are included
4. 3 learning paths for different audiences are provided
5. 10+ external resources and 10+ FAQ items are included

### Key Differentiator from Task 1-5

**Task 1-5**: "Here's how CPG implements X" (assumes you know what X is)
**Task 7**: "Here's what X is and why CPG needs it" (teaches X from scratch)

**Target Outcome**: After reading Task 7, readers can confidently read Task 1-5 without feeling lost.

---

## IMPORTANT: Memory-First Reminder

**BEFORE writing ANY document, ALWAYS**:
1. Check semantic notes for existing concept explanations
2. Check episodic notes for examples and code references
3. Use task-specific indexes to read selectively (avoid re-reading 8000+ lines)
4. Update memory IMMEDIATELY after each step (not at the end)

**Concept inventory already created**: `/claude/temp/task-7/brainstorm/PL_CONCEPTS_INVENTORY.md`

---

**Total estimated output**: 12,000-18,000 lines across 6 documents
**Estimated execution time**: 4-6 hours (with incremental approach and memory-first strategy)
